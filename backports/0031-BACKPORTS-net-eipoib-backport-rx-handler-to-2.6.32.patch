From: Erez Shitrit <erezsh@mellanox.com>
Subject: [PATCH] BACKPORTS: net/eipoib: backport rx handler to 2.6.32

The eipoib driver uses the netdev_rx_handler_register framework
to register a handler which hooks all the rx calls made by ipoib
devices which are in use by eipoib.  In 2.6.32 there's no such generic
mechanism, and hence we went in the ugly way of using a function pointer
exported by IPoIB and filled by eIPoIB.

This works but creates explicit dependancy between the modules,
which has the side effect of IPoIB to be unloaded when one does
modprobe -r on eIPoIB. We can try and fix that out using things
like symbol_get/put

Signed-off-by: Or Gerlitz <ogerlitz@mellanox.com>
Signed-off-by: Erez Shitrit <erezsh@mellanox.com>
---
 drivers/net/eipoib/eth_ipoib_main.c |   22 ++++++++++++++++++++++
 1 files changed, 22 insertions(+), 0 deletions(-)

diff --git a/drivers/net/eipoib/eth_ipoib_main.c b/drivers/net/eipoib/eth_ipoib_main.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/eipoib/eth_ipoib_main.c
+++ b/drivers/net/eipoib/eth_ipoib_main.c
@@ -47,6 +47,12 @@
 #define PARENT_MAC_MASK 0xe7
 
 /* forward declaration */
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36))
+typedef int rx_handler_result_t;
+#define RX_HANDLER_CONSUMED 0
+extern int (*eth_ipoib_handle_frame_hook)(struct sk_buff **skb);
+#endif
+
 static rx_handler_result_t eipoib_handle_frame(struct sk_buff **pskb);
 static int eipoib_device_event(struct notifier_block *unused,
 			       unsigned long event, void *ptr);
@@ -536,6 +542,7 @@ int parent_enslave(struct net_device *parent_dev, struct net_device *slave_dev)
 	if (res)
 		goto err_close;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	/* register handler */
 	res = netdev_rx_handler_register(slave_dev, eipoib_handle_frame,
 					 new_slave);
@@ -544,6 +551,7 @@ int parent_enslave(struct net_device *parent_dev, struct net_device *slave_dev)
 			parent_dev->name, res);
 		goto err_close;
 	}
+#endif
 
 	pr_info("%s: enslaving %s\n", parent_dev->name, slave_dev->name);
 
@@ -575,7 +583,9 @@ static void slave_free(struct parent *parent, struct slave *slave)
 		kfree(neigh);
 	}
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	netdev_rx_handler_unregister(slave->dev);
+#endif
 
 	kfree(slave);
 }
@@ -1532,7 +1542,11 @@ static rx_handler_result_t eipoib_handle_frame(struct sk_buff **pskb)
 	struct sk_buff *skb = *pskb;
 	struct slave *slave;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36))
 	slave = eipoib_slave_get_rcu(skb->dev);
+#else
+	slave = get_slave_by_dev(netdev_priv(skb->dev->master), skb->dev);
+#endif
 
 	parent_rx(skb, slave);
 
@@ -2055,6 +2069,10 @@ static int __init mod_init(void)
 		goto unreg_subsys;
 	}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36))
+	eth_ipoib_handle_frame_hook = eipoib_handle_frame;
+#endif
+
 	goto out;
 
 unreg_subsys:
@@ -2070,6 +2088,10 @@ static void __exit mod_exit(void)
 
 	unregister_pernet_subsys(&eipoib_net_ops);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(2,6,36))
+	eth_ipoib_handle_frame_hook = NULL;
+#endif
+
 	rtnl_lock();
 	parent_free_all();
 	rtnl_unlock();
