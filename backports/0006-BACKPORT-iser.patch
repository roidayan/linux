From: Alaa Hleihel <alaa@mellanox.com>
Subject: [PATCH] BACKPORT: iser

Signed-off-by: Alaa Hleihel <alaa@mellanox.com>
---
 drivers/infiniband/ulp/iser/iscsi_iser.c     | 46 ++++++++++++++-
 drivers/infiniband/ulp/iser/iser_initiator.c | 10 ++++
 drivers/infiniband/ulp/iser/iser_memory.c    | 83 ++++++++++++++++++++++++++++
 3 files changed, 138 insertions(+), 1 deletion(-)

diff --git a/drivers/infiniband/ulp/iser/iscsi_iser.c b/drivers/infiniband/ulp/iser/iscsi_iser.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/iser/iscsi_iser.c
+++ b/drivers/infiniband/ulp/iser/iscsi_iser.c
@@ -97,7 +97,11 @@ module_param_named(pi_enable, iser_pi_enable, bool, 0644);
 MODULE_PARM_DESC(pi_enable, "Enable T10-PI offload support (default:disabled)");
 
 module_param_named(pi_guard, iser_pi_guard, int, 0644);
+#ifdef HAVE_SCSI_PROT_INTERVAL
 MODULE_PARM_DESC(pi_guard, "T10-PI guard_type [deprecated]");
+#else
+MODULE_PARM_DESC(pi_guard, "T10-PI guard_type, 0:CRC|1:IP_CSUM (default:IP_CSUM)");
+#endif
 
 static struct workqueue_struct *release_wq;
 struct iser_global ig;
@@ -381,6 +385,7 @@ static void iscsi_iser_cleanup_task(struct iscsi_task *task)
 	}
 }
 
+#ifdef HAVE_ISCSI_CHECK_PROTECTION
 /**
  * iscsi_iser_check_protection() - check protection information status of task.
  * @task:     iscsi task
@@ -405,6 +410,7 @@ iscsi_iser_check_protection(struct iscsi_task *task, sector_t *sector)
 		return iser_check_task_pi_status(iser_task, ISER_DIR_OUT,
 						 sector);
 }
+#endif
 
 /**
  * iscsi_iser_conn_create() - create a new iscsi-iser connection
@@ -574,6 +580,7 @@ iscsi_iser_session_destroy(struct iscsi_cls_session *cls_session)
 static inline unsigned int
 iser_dif_prot_caps(int prot_caps)
 {
+#ifdef HAVE_SCSI_PROT_INTERVAL
 	return ((prot_caps & IB_PROT_T10DIF_TYPE_1) ?
 		SHOST_DIF_TYPE1_PROTECTION | SHOST_DIX_TYPE0_PROTECTION |
 		SHOST_DIX_TYPE1_PROTECTION : 0) |
@@ -581,6 +588,14 @@ iser_dif_prot_caps(int prot_caps)
 		SHOST_DIF_TYPE2_PROTECTION | SHOST_DIX_TYPE2_PROTECTION : 0) |
 	       ((prot_caps & IB_PROT_T10DIF_TYPE_3) ?
 		SHOST_DIF_TYPE3_PROTECTION | SHOST_DIX_TYPE3_PROTECTION : 0);
+#else
+	return ((prot_caps & IB_PROT_T10DIF_TYPE_1) ? SHOST_DIF_TYPE1_PROTECTION |
+												  SHOST_DIX_TYPE1_PROTECTION : 0) |
+		   ((prot_caps & IB_PROT_T10DIF_TYPE_2) ? SHOST_DIF_TYPE2_PROTECTION |
+												  SHOST_DIX_TYPE2_PROTECTION : 0) |
+		   ((prot_caps & IB_PROT_T10DIF_TYPE_3) ? SHOST_DIF_TYPE3_PROTECTION |
+												  SHOST_DIX_TYPE3_PROTECTION : 0);
+#endif
 }
 
 /**
@@ -636,8 +651,15 @@ iscsi_iser_session_create(struct iscsi_endpoint *ep,
 			u32 sig_caps = ib_conn->device->dev_attr.sig_prot_cap;
 
 			scsi_host_set_prot(shost, iser_dif_prot_caps(sig_caps));
+#ifdef HAVE_SCSI_PROT_INTERVAL
 			scsi_host_set_guard(shost, SHOST_DIX_GUARD_IP |
 						   SHOST_DIX_GUARD_CRC);
+#else
+			if (iser_pi_guard)
+				scsi_host_set_guard(shost, SHOST_DIX_GUARD_IP);
+			else
+				scsi_host_set_guard(shost, SHOST_DIX_GUARD_CRC);
+#endif
 		}
 
 		if (iscsi_host_add(shost,
@@ -753,6 +775,7 @@ iscsi_iser_conn_get_stats(struct iscsi_cls_conn *cls_conn, struct iscsi_stats *s
 	stats->custom[3].value = conn->fmr_unalign_cnt;
 }
 
+#ifdef HAVE_ISCSI_GET_EP_PARAM
 static int iscsi_iser_get_ep_param(struct iscsi_endpoint *ep,
 				   enum iscsi_param param, char *buf)
 {
@@ -775,6 +798,7 @@ static int iscsi_iser_get_ep_param(struct iscsi_endpoint *ep,
 
 	return len;
 }
+#endif
 
 /**
  * iscsi_iser_ep_connect() - Initiate iSER connection establishment
@@ -903,6 +927,7 @@ iscsi_iser_ep_disconnect(struct iscsi_endpoint *ep)
 	iscsi_destroy_endpoint(ep);
 }
 
+#ifdef HAVE_ISCSI_ATTR_IS_VISIBLE
 static umode_t iser_attr_is_visible(int param_type, int param)
 {
 	switch (param_type) {
@@ -947,7 +972,9 @@ static umode_t iser_attr_is_visible(int param_type, int param)
 		case ISCSI_PARAM_TGT_RESET_TMO:
 		case ISCSI_PARAM_IFACE_NAME:
 		case ISCSI_PARAM_INITIATOR_NAME:
+#ifdef HAVE_ISCSI_PARAM_DISCOVERY_SESS
 		case ISCSI_PARAM_DISCOVERY_SESS:
+#endif
 			return S_IRUGO;
 		default:
 			return 0;
@@ -956,23 +983,34 @@ static umode_t iser_attr_is_visible(int param_type, int param)
 
 	return 0;
 }
+#endif
 
 static struct scsi_host_template iscsi_iser_sht = {
 	.module                 = THIS_MODULE,
 	.name                   = "iSCSI Initiator over iSER",
 	.queuecommand           = iscsi_queuecommand,
-	.change_queue_depth	= scsi_change_queue_depth,
+#ifdef HAVE_ISCSI_CHANGE_QUEUE_DEPTH
+	.change_queue_depth	= iscsi_change_queue_depth,
+#else
+	.change_queue_depth = scsi_change_queue_depth,
+#endif
 	.sg_tablesize           = ISCSI_ISER_SG_TABLESIZE,
 	.max_sectors		= 1024,
 	.cmd_per_lun            = ISER_DEF_CMD_PER_LUN,
 	.eh_abort_handler       = iscsi_eh_abort,
 	.eh_device_reset_handler= iscsi_eh_device_reset,
+#ifdef HAVE_ISCSI_EH_TARGET_RESET
+	.eh_target_reset_handler = iscsi_eh_target_reset,
+#else
 	.eh_target_reset_handler = iscsi_eh_recover_target,
+#endif
 	.target_alloc		= iscsi_target_alloc,
 	.use_clustering         = DISABLE_CLUSTERING,
 	.proc_name              = "iscsi_iser",
 	.this_id                = -1,
+#ifdef HAVE_TRACK_QUEUE_DEPTH
 	.track_queue_depth	= 1,
+#endif
 };
 
 static struct iscsi_transport iscsi_iser_transport = {
@@ -986,10 +1024,14 @@ static struct iscsi_transport iscsi_iser_transport = {
 	.create_conn            = iscsi_iser_conn_create,
 	.bind_conn              = iscsi_iser_conn_bind,
 	.destroy_conn           = iscsi_conn_teardown,
+#ifdef HAVE_ISCSI_ATTR_IS_VISIBLE
 	.attr_is_visible	= iser_attr_is_visible,
+#endif
 	.set_param              = iscsi_iser_set_param,
 	.get_conn_param		= iscsi_conn_get_param,
+#ifdef HAVE_ISCSI_GET_EP_PARAM
 	.get_ep_param		= iscsi_iser_get_ep_param,
+#endif
 	.get_session_param	= iscsi_session_get_param,
 	.start_conn             = iscsi_iser_conn_start,
 	.stop_conn              = iscsi_iser_conn_stop,
@@ -1003,7 +1045,9 @@ static struct iscsi_transport iscsi_iser_transport = {
 	.xmit_task		= iscsi_iser_task_xmit,
 	.cleanup_task		= iscsi_iser_cleanup_task,
 	.alloc_pdu		= iscsi_iser_pdu_alloc,
+#ifdef HAVE_ISCSI_CHECK_PROTECTION
 	.check_protection	= iscsi_iser_check_protection,
+#endif
 	/* recovery */
 	.session_recovery_timedout = iscsi_session_recovery_timedout,
 
diff --git a/drivers/infiniband/ulp/iser/iser_initiator.c b/drivers/infiniband/ulp/iser/iser_initiator.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/iser/iser_initiator.c
+++ b/drivers/infiniband/ulp/iser/iser_initiator.c
@@ -342,7 +342,9 @@ static int iser_post_rx_bufs(struct iscsi_conn *conn, struct iscsi_hdr *req)
 {
 	struct iser_conn *iser_conn = conn->dd_data;
 	struct ib_conn *ib_conn = &iser_conn->ib_conn;
+#ifdef HAVE_ISCSI_DISCOVERY_SESS
 	struct iscsi_session *session = conn->session;
+#endif
 
 	iser_dbg("req op %x flags %x\n", req->opcode, req->flags);
 	/* check if this is the last login - going to full feature phase */
@@ -355,12 +357,16 @@ static int iser_post_rx_bufs(struct iscsi_conn *conn, struct iscsi_hdr *req)
 	 */
 	WARN_ON(ib_conn->post_recv_buf_count != 1);
 
+#ifdef HAVE_ISCSI_DISCOVERY_SESS
 	if (session->discovery_sess) {
 		iser_info("Discovery session, re-using login RX buffer\n");
 		return 0;
 	} else
 		iser_info("Normal session, posting batch of RX %d buffers\n",
 			  iser_conn->min_posted_rx);
+#else
+	iser_dbg("Initially post: %d\n", ISER_MIN_POSTED_RX);
+#endif
 
 	/* Initial post receive buffers */
 	if (iser_post_recvm(iser_conn, iser_conn->min_posted_rx))
@@ -385,7 +391,11 @@ int iser_send_command(struct iscsi_conn *conn,
 	unsigned long edtl;
 	int err;
 	struct iser_data_buf *data_buf, *prot_buf;
+#ifdef HAVE_ISCSI_SCSI_REQ
 	struct iscsi_scsi_req *hdr = (struct iscsi_scsi_req *)task->hdr;
+#else
+	struct iscsi_cmd *hdr =  (struct iscsi_cmd *)task->hdr;
+#endif
 	struct scsi_cmnd *sc  =  task->sc;
 	struct iser_tx_desc *tx_desc = &iser_task->desc;
 	u8 sig_count = ++iser_conn->ib_conn.sig_count;
diff --git a/drivers/infiniband/ulp/iser/iser_memory.c b/drivers/infiniband/ulp/iser/iser_memory.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/infiniband/ulp/iser/iser_memory.c
+++ b/drivers/infiniband/ulp/iser/iser_memory.c
@@ -39,7 +39,11 @@
 
 #include "iscsi_iser.h"
 
+#if  (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,32))
+#define ISER_KMALLOC_THRESHOLD 0x80000 /* 512K - kmalloc limit */
+#else
 #define ISER_KMALLOC_THRESHOLD 0x20000 /* 128K - kmalloc limit */
+#endif
 
 /**
  * iser_start_rdma_unaligned_sg
@@ -78,11 +82,19 @@ static int iser_start_rdma_unaligned_sg(struct iscsi_iser_task *iser_task,
 		sgl = (struct scatterlist *)data->buf;
 		p = mem;
 		for_each_sg(sgl, sg, data->size, i) {
+#if  (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
 			from = kmap_atomic(sg_page(sg));
+#else
+			from = kmap_atomic(sg_page(sg), KM_USER0);
+#endif
 			memcpy(p,
 			       from + sg->offset,
 			       sg->length);
+#if  (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
 			kunmap_atomic(from);
+#else
+			kunmap_atomic(from, KM_USER0);
+#endif
 			p += sg->length;
 		}
 	}
@@ -136,11 +148,19 @@ void iser_finalize_rdma_unaligned_sg(struct iscsi_iser_task *iser_task,
 
 		p = mem;
 		for_each_sg(sgl, sg, sg_size, i) {
+#if  (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
 			to = kmap_atomic(sg_page(sg));
+#else
+			to = kmap_atomic(sg_page(sg), KM_USER0);
+#endif
 			memcpy(to + sg->offset,
 			       p,
 			       sg->length);
+#if  (LINUX_VERSION_CODE >= KERNEL_VERSION(3,4,0))
 			kunmap_atomic(to);
+#else
+			kunmap_atomic(to, KM_USER0);
+#endif
 			p += sg->length;
 		}
 	}
@@ -438,13 +458,22 @@ int iser_reg_rdma_mem_fmr(struct iscsi_iser_task *iser_task,
 	return 0;
 }
 
+#ifdef HAVE_SCSI_PROT_INTERVAL
 static void
+#else
+static inline void
+#endif
 iser_set_dif_domain(struct scsi_cmnd *sc, struct ib_sig_attrs *sig_attrs,
 		    struct ib_sig_domain *domain)
 {
 	domain->sig_type = IB_SIG_TYPE_T10_DIF;
+#ifdef HAVE_SCSI_PROT_INTERVAL
 	domain->sig.dif.pi_interval = scsi_prot_interval(sc);
 	domain->sig.dif.ref_tag = scsi_prot_ref_tag(sc);
+#else
+	domain->sig.dif.pi_interval = sc->device->sector_size;
+	domain->sig.dif.ref_tag = scsi_get_lba(sc) & 0xffffffff;
+#endif
 	/*
 	 * At the moment we hard code those, but in the future
 	 * we will take them from sc.
@@ -452,7 +481,12 @@ iser_set_dif_domain(struct scsi_cmnd *sc, struct ib_sig_attrs *sig_attrs,
 	domain->sig.dif.apptag_check_mask = 0xffff;
 	domain->sig.dif.app_escape = true;
 	domain->sig.dif.ref_escape = true;
+#ifdef HAVE_SCSI_PROT_INTERVAL
 	if (sc->prot_flags & SCSI_PROT_REF_INCREMENT)
+#else
+	if (scsi_get_prot_type(sc) == SCSI_PROT_DIF_TYPE1 ||
+		scsi_get_prot_type(sc) == SCSI_PROT_DIF_TYPE2)
+#endif
 		domain->sig.dif.ref_remap = true;
 };
 
@@ -470,16 +504,26 @@ iser_set_sig_attrs(struct scsi_cmnd *sc, struct ib_sig_attrs *sig_attrs)
 	case SCSI_PROT_WRITE_STRIP:
 		sig_attrs->wire.sig_type = IB_SIG_TYPE_NONE;
 		iser_set_dif_domain(sc, sig_attrs, &sig_attrs->mem);
+#ifdef HAVE_SCSI_PROT_INTERVAL
 		sig_attrs->mem.sig.dif.bg_type = sc->prot_flags & SCSI_PROT_IP_CHECKSUM ?
 						IB_T10DIF_CSUM : IB_T10DIF_CRC;
+#else
+		sig_attrs->mem.sig.dif.bg_type = iser_pi_guard ? IB_T10DIF_CSUM :
+						IB_T10DIF_CRC;
+#endif
 		break;
 	case SCSI_PROT_READ_PASS:
 	case SCSI_PROT_WRITE_PASS:
 		iser_set_dif_domain(sc, sig_attrs, &sig_attrs->wire);
 		sig_attrs->wire.sig.dif.bg_type = IB_T10DIF_CRC;
 		iser_set_dif_domain(sc, sig_attrs, &sig_attrs->mem);
+#ifdef HAVE_SCSI_PROT_INTERVAL
 		sig_attrs->mem.sig.dif.bg_type = sc->prot_flags & SCSI_PROT_IP_CHECKSUM ?
 						IB_T10DIF_CSUM : IB_T10DIF_CRC;
+#else
+		sig_attrs->mem.sig.dif.bg_type = iser_pi_guard ? IB_T10DIF_CSUM :
+						IB_T10DIF_CRC;
+#endif
 		break;
 	default:
 		iser_err("Unsupported PI operation %d\n",
@@ -490,14 +534,38 @@ iser_set_sig_attrs(struct scsi_cmnd *sc, struct ib_sig_attrs *sig_attrs)
 	return 0;
 }
 
+#ifdef HAVE_SCSI_PROT_INTERVAL
 static inline void
+#else
+static int
+#endif
 iser_set_prot_checks(struct scsi_cmnd *sc, u8 *mask)
 {
+#ifdef HAVE_SCSI_PROT_INTERVAL
 	*mask = 0;
 	if (sc->prot_flags & SCSI_PROT_REF_CHECK)
 		*mask |= ISER_CHECK_REFTAG;
 	if (sc->prot_flags & SCSI_PROT_GUARD_CHECK)
 		*mask |= ISER_CHECK_GUARD;
+#else
+	switch (scsi_get_prot_type(sc)) {
+	case SCSI_PROT_DIF_TYPE0:
+		break;
+	case SCSI_PROT_DIF_TYPE1:
+	case SCSI_PROT_DIF_TYPE2:
+		*mask = ISER_CHECK_GUARD | ISER_CHECK_REFTAG;
+		break;
+	case SCSI_PROT_DIF_TYPE3:
+		*mask = ISER_CHECK_GUARD;
+		break;
+	default:
+		iser_err("Unsupported protection type %d\n",
+				scsi_get_prot_type(sc));
+		return -EINVAL;
+	}
+
+	return 0;
+#endif
 }
 
 static void
@@ -531,7 +599,13 @@ iser_reg_sig_mr(struct iscsi_iser_task *iser_task,
 	if (ret)
 		goto err;
 
+#ifdef HAVE_SCSI_PROT_INTERVAL
 	iser_set_prot_checks(iser_task->sc, &sig_attrs.check_mask);
+#else
+	ret = iser_set_prot_checks(iser_task->sc, &sig_attrs.check_mask);
+	if (ret)
+		goto err;
+#endif
 
 	if (!(desc->reg_indicators & ISER_SIG_KEY_VALID)) {
 		iser_inv_rkey(&inv_wr, pi_ctx->sig_mr);
@@ -565,7 +639,16 @@ iser_reg_sig_mr(struct iscsi_iser_task *iser_task,
 
 	sig_sge->lkey = pi_ctx->sig_mr->lkey;
 	sig_sge->addr = 0;
+#ifdef HAVE_SCSI_PROT_INTERVAL
 	sig_sge->length = scsi_transfer_length(iser_task->sc);
+#else
+	sig_sge->length = data_sge->length + prot_sge->length;
+	if (scsi_get_prot_op(iser_task->sc) == SCSI_PROT_WRITE_INSERT ||
+		scsi_get_prot_op(iser_task->sc) == SCSI_PROT_READ_STRIP) {
+			sig_sge->length += (data_sge->length /
+								iser_task->sc->device->sector_size) * 8;
+	}
+#endif
 
 	iser_dbg("sig_sge: addr: 0x%llx  length: %u lkey: 0x%x\n",
 		 sig_sge->addr, sig_sge->length,
