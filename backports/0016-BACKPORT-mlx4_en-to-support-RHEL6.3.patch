From 6aa12629dd921e148d9f5bde8b8aae0a4480e7a8 Mon Sep 17 00:00:00 2001
From: Yan Burman <yanb@mellanox.com>
Date: Thu, 24 Jan 2013 16:58:06 +0200
Subject: [PATCH] BACKPORT: mlx4_en to support RHEL6.3

Signed-off-by: Vladimir Sokolovsky <vlad@mellanox.com>
Signed-off-by: Yan Burman <yanb@mellanox.com>
---
 drivers/net/ethernet/mellanox/mlx4/en_cq.c      |    6 +++
 drivers/net/ethernet/mellanox/mlx4/en_ethtool.c |   20 ++++++++++-
 drivers/net/ethernet/mellanox/mlx4/en_netdev.c  |   42 +++++++++++++++++++++++
 drivers/net/ethernet/mellanox/mlx4/en_tx.c      |    9 +++++
 drivers/net/ethernet/mellanox/mlx4/eq.c         |    8 ++++
 include/linux/mlx4/device.h                     |    6 +++
 6 files changed, 88 insertions(+), 1 deletions(-)

diff --git a/drivers/net/ethernet/mellanox/mlx4/en_cq.c b/drivers/net/ethernet/mellanox/mlx4/en_cq.c
index 4b172a9..16814e5 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_cq.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_cq.c
@@ -99,12 +99,14 @@ int mlx4_en_activate_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq,
 	int err = 0;
 	char name[25];
 	int timestamp_en = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	struct cpu_rmap *rmap =
 #ifdef CONFIG_RFS_ACCEL
 		priv->dev->rx_cpu_rmap;
 #else
 		NULL;
 #endif
+#endif
 
 	cq->dev = mdev->pndev[priv->port];
 	cq->mcq.set_ci_db  = cq->wqres.db.db;
@@ -119,8 +119,12 @@ int mlx4_en_activate_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq,
 				sprintf(name, "%s-%d", priv->dev->name,
 					cq->ring);
 				/* Set IRQ for specific name (per ring) */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 				if (mlx4_assign_eq(mdev->dev, name, rmap,
 						   &cq->vector)) {
+#else
+				if (mlx4_assign_eq(mdev->dev, name, &cq->vector)) {
+#endif
 					cq->vector = (cq->ring + 1 + priv->port)
 					    % mdev->dev->caps.num_comp_vectors;
 					mlx4_warn(mdev, "Failed Assigning an EQ to "
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index a3e277d..0de5b43 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@ -85,6 +85,14 @@ struct mlx4_ethtool_rxnfc {
 #define	FLOW_MAC_EXT	0x40000000
 #endif
 
+#ifndef FLOW_EXT
+#define	FLOW_EXT	0x80000000
+#endif
+
+#ifndef ETHER_FLOW
+#define	ETHER_FLOW	0x12	/* spec only (ether_spec) */
+#endif
+
 static void
 mlx4_en_get_drvinfo(struct net_device *dev, struct ethtool_drvinfo *drvinfo)
 {
@@ -1075,8 +1083,13 @@ static int mlx4_en_get_num_flows(struct mlx4_en_priv *priv)
 
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
 static int mlx4_en_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *c,
 			     u32 *rule_locs)
+#else
+static int mlx4_en_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *c,
+			     void *rule_locs)
+#endif
 {
 	struct mlx4_en_priv *priv = netdev_priv(dev);
 	struct mlx4_en_dev *mdev = priv->mdev;
@@ -1104,8 +1117,13 @@ static int mlx4_en_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *c,
 	case ETHTOOL_GRXCLSRLALL:
 		while ((!err || err == -ENOENT) && priority < cmd->rule_cnt) {
 			err = mlx4_en_get_flow(dev, cmd, i);
-			if (!err)
+			if (!err) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
 				rule_locs[priority++] = i;
+#else
+				((u32 *)(rule_locs))[priority++] = i;
+#endif
+			}
 			i++;
 		}
 		err = 0;
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 062f6dc..13bffbb 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -47,6 +47,7 @@
 #include "mlx4_en.h"
 #include "en_port.h"
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 static int mlx4_en_setup_tc(struct net_device *dev, u8 up)
 {
 	struct mlx4_en_priv *priv = netdev_priv(dev);
@@ -67,6 +68,7 @@ static int mlx4_en_setup_tc(struct net_device *dev, u8 up)
 
 	return 0;
 }
+#endif
 
 #ifdef CONFIG_RFS_ACCEL
 
@@ -692,18 +694,30 @@ static void mlx4_en_clear_list(struct net_device *dev)
 static void mlx4_en_cache_mclist(struct net_device *dev)
 {
 	struct mlx4_en_priv *priv = netdev_priv(dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	struct netdev_hw_addr *ha;
+#else
+	struct dev_mc_list *mclist;
+#endif
 	struct mlx4_en_mc_list *tmp;
 
 	mlx4_en_clear_list(dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	netdev_for_each_mc_addr(ha, dev) {
+#else
+	for (mclist = dev->mc_list; mclist; mclist = mclist->next) {
+#endif
 		tmp = kzalloc(sizeof(struct mlx4_en_mc_list), GFP_ATOMIC);
 		if (!tmp) {
 			en_err(priv, "failed to allocate multicast list\n");
 			mlx4_en_clear_list(dev);
 			return;
 		}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 		memcpy(tmp->addr, ha->addr, ETH_ALEN);
+#else
+		memcpy(tmp->addr, mclist->dmi_addr, ETH_ALEN);
+#endif
 		list_add_tail(&tmp->list, &priv->mc_list);
 	}
 }
@@ -1144,7 +1158,11 @@ static void mlx4_en_do_set_rx_mode(struct work_struct *work)
 		}
 	}
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 	if (dev->priv_flags & IFF_UNICAST_FLT)
+#else
+	if (mdev->dev->caps.steering_mode != MLX4_STEERING_MODE_A0)
+#endif
 		mlx4_en_do_uc_filter(priv, dev, mdev);
 
 	/* Promsicuous mode: disable all filters */
@@ -1996,6 +2014,7 @@ static int mlx4_en_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	}
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 static int mlx4_en_set_features(struct net_device *netdev,
 		netdev_features_t features)
 {
@@ -2012,6 +2031,7 @@ static int mlx4_en_set_features(struct net_device *netdev,
 	return 0;
 
 }
+#endif
 
 static int mlx4_en_set_vf_mac(struct net_device *dev, int queue, u8 *mac)
 {
@@ -2130,8 +2150,10 @@ static const struct net_device_ops mlx4_netdev_ops = {
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller	= mlx4_en_netpoll,
 #endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	.ndo_set_features	= mlx4_en_set_features,
 	.ndo_setup_tc		= mlx4_en_setup_tc,
+#endif
 #ifdef CONFIG_RFS_ACCEL
 	.ndo_rx_flow_steer	= mlx4_en_filter_rfs,
 #endif
@@ -2300,6 +2322,7 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	/*
 	 * Set driver features
 	 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	dev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | NETIF_F_GRO;
 	if (mdev->LSO_support)
 		dev->hw_features |= NETIF_F_TSO | NETIF_F_TSO6;
@@ -2316,9 +2339,28 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	    MLX4_STEERING_MODE_DEVICE_MANAGED)
 		dev->hw_features |= NETIF_F_NTUPLE;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0))
 	if (mdev->dev->caps.steering_mode != MLX4_STEERING_MODE_A0)
 		dev->priv_flags |= IFF_UNICAST_FLT;
+#endif
+
+#else
+	dev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
+	if (mdev->LSO_support)
+		dev->features |= NETIF_F_TSO | NETIF_F_TSO6;
+
+	dev->vlan_features = dev->features;
 
+	dev->features |= NETIF_F_RXCSUM | NETIF_F_RXHASH;
+	dev->features |= NETIF_F_HIGHDMA |
+		NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX |
+		NETIF_F_HW_VLAN_FILTER;
+
+	if (mdev->dev->caps.steering_mode ==
+			MLX4_STEERING_MODE_DEVICE_MANAGED)
+		dev->features |= NETIF_F_NTUPLE;
+#endif
+	
 	mdev->pndev[port] = dev;
 
 	netif_carrier_off(dev);
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_tx.c b/drivers/net/ethernet/mellanox/mlx4/en_tx.c
index 0b0dd4f..b3bb5e0 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_tx.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_tx.c
@@ -629,7 +629,11 @@ u16 mlx4_en_select_queue(struct net_device *dev, struct sk_buff *skb)
 	u16 rings_p_up = priv->mdev->profile.num_tx_rings_p_up;
 	u8 up = 0;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	if (dev->num_tc)
+#else
+	if (netdev_get_num_tc(dev))
+#endif
 		return skb_tx_hash(dev, skb);
 
 	if (vlan_tx_tag_present(skb))
@@ -730,8 +734,13 @@ netdev_tx_t mlx4_en_xmit(struct sk_buff *skb, struct net_device *dev)
 	 * set flag for further reference
 	 */
 	if (ring->hwtstamp_tx_type == HWTSTAMP_TX_ON &&
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)
 	    skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {
 		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+#else
+	    skb_shinfo(skb)->tx_flags.flags & SKBTX_HW_TSTAMP) {
+		skb_shinfo(skb)->tx_flags.flags |= SKBTX_IN_PROGRESS;
+#endif
 		tx_info->ts_requested = 1;
 	}
 
diff --git a/drivers/net/ethernet/mellanox/mlx4/eq.c b/drivers/net/ethernet/mellanox/mlx4/eq.c
index afd29a6..74954d5 100644
--- a/drivers/net/ethernet/mellanox/mlx4/eq.c
+++ b/drivers/net/ethernet/mellanox/mlx4/eq.c
@@ -39,7 +39,9 @@
 #include <linux/dma-mapping.h>
 
 #include <linux/mlx4/cmd.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 #include <linux/cpu_rmap.h>
+#endif
 
 #include "mlx4.h"
 #include "fw.h"
@@ -1308,8 +1310,12 @@ int mlx4_test_interrupts(struct mlx4_dev *dev)
 }
 EXPORT_SYMBOL(mlx4_test_interrupts);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 int mlx4_assign_eq(struct mlx4_dev *dev, char *name, struct cpu_rmap *rmap,
 		   int *vector)
+#else
+int mlx4_assign_eq(struct mlx4_dev *dev, char* name, int * vector)
+#endif
 {
 
 	struct mlx4_priv *priv = mlx4_priv(dev);
@@ -1323,6 +1329,7 @@ int mlx4_assign_eq(struct mlx4_dev *dev, char *name, struct cpu_rmap *rmap,
 			snprintf(priv->eq_table.irq_names +
 					vec * MLX4_IRQNAME_SIZE,
 					MLX4_IRQNAME_SIZE, "%s", name);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 #ifdef CONFIG_RFS_ACCEL
 			if (rmap) {
 				err = irq_cpu_rmap_add(rmap,
@@ -1331,6 +1338,7 @@ int mlx4_assign_eq(struct mlx4_dev *dev, char *name, struct cpu_rmap *rmap,
 					mlx4_warn(dev, "Failed adding irq rmap\n");
 			}
 #endif
+#endif
 			err = request_irq(priv->eq_table.eq[vec].irq,
 					  mlx4_msi_x_interrupt, 0,
 					  &priv->eq_table.irq_names[vec<<5],
diff --git a/include/linux/mlx4/device.h b/include/linux/mlx4/device.h
index 5806d4c..7c90370 100644
--- a/include/linux/mlx4/device.h
+++ b/include/linux/mlx4/device.h
@@ -36,7 +36,9 @@
 #include <linux/pci.h>
 #include <linux/completion.h>
 #include <linux/radix-tree.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 #include <linux/cpu_rmap.h>
+#endif
 
 #include <linux/atomic.h>
 
@@ -1080,8 +1082,12 @@ int mlx4_query_diag_counters(struct mlx4_dev *mlx4_dev, int array_length,
 			     u32 counter_out[]);
 
 int mlx4_test_interrupts(struct mlx4_dev *dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 int mlx4_assign_eq(struct mlx4_dev *dev, char *name, struct cpu_rmap *rmap,
 		   int *vector);
+#else
+int mlx4_assign_eq(struct mlx4_dev *dev, char* name , int* vector);
+#endif
 void mlx4_release_eq(struct mlx4_dev *dev, int vec);
 
 int mlx4_wol_read(struct mlx4_dev *dev, u64 *config, int port);
-- 
1.7.1

