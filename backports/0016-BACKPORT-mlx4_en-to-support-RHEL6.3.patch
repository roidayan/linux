From 72909fab3c1b28cd50c1d338f272f291b25d688c Mon Sep 17 00:00:00 2001
From: Vladimir Sokolovsky <vlad@mellanox.com>
Date: Wed, 5 Dec 2012 13:31:23 +0200
Subject: [PATCH] BACKPORT: mlx4_en to support RHEL6.3

Signed-off-by: Vladimir Sokolovsky <vlad@mellanox.com>
---
 drivers/net/ethernet/mellanox/mlx4/en_cq.c      |    4 ++
 drivers/net/ethernet/mellanox/mlx4/en_ethtool.c |   33 ++++++++++++++++++-
 drivers/net/ethernet/mellanox/mlx4/en_netdev.c  |   38 ++++++++++++++++++++++-
 drivers/net/ethernet/mellanox/mlx4/en_tx.c      |    9 +++++
 drivers/net/ethernet/mellanox/mlx4/eq.c         |    8 +++++
 include/linux/mlx4/device.h                     |    6 +++
 6 files changed, 95 insertions(+), 3 deletions(-)

diff --git a/drivers/net/ethernet/mellanox/mlx4/en_cq.c b/drivers/net/ethernet/mellanox/mlx4/en_cq.c
index 4b172a9..16814e5 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_cq.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_cq.c
@@ -119,8 +119,12 @@ int mlx4_en_activate_cq(struct mlx4_en_priv *priv, struct mlx4_en_cq *cq,
 				sprintf(name, "%s-%d", priv->dev->name,
 					cq->ring);
 				/* Set IRQ for specific name (per ring) */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 				if (mlx4_assign_eq(mdev->dev, name, rmap,
 						   &cq->vector)) {
+#else
+				if (mlx4_assign_eq(mdev->dev, name, &cq->vector)) {
+#endif
 					cq->vector = (cq->ring + 1 + priv->port)
 					    % mdev->dev->caps.num_comp_vectors;
 					mlx4_warn(mdev, "Failed Assigning an EQ to "
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index c23d97b..6ec3c74 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@ -651,14 +651,20 @@ static int mlx4_en_validate_flow(struct net_device *dev,
 {
 	struct ethtool_usrip4_spec *l3_mask;
 	struct ethtool_tcpip4_spec *l4_mask;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
 	struct ethhdr *eth_mask;
 	u64 full_mac = ~0ull;
 	u64 zero_mac = 0;
+#endif
 
 	if (cmd->fs.location >= MAX_NUM_OF_FS_RULES)
 		return -EINVAL;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
 	switch (cmd->fs.flow_type & ~FLOW_EXT) {
+#else
+	switch (cmd->fs.flow_type) {
+#endif
 	case TCP_V4_FLOW:
 	case UDP_V4_FLOW:
 		if (cmd->fs.m_u.tcp_ip4_spec.tos)
@@ -680,6 +686,7 @@ static int mlx4_en_validate_flow(struct net_device *dev,
 		    !all_zeros_or_all_ones(l3_mask->ip4dst))
 			return -EINVAL;
 		break;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
 	case ETHER_FLOW:
 		eth_mask = &cmd->fs.m_u.ether_spec;
 		/* source mac mask must not be set */
@@ -693,10 +700,12 @@ static int mlx4_en_validate_flow(struct net_device *dev,
 		if (!all_zeros_or_all_ones(eth_mask->h_proto))
 			return -EINVAL;
 		break;
+#endif
 	default:
 		return -EINVAL;
 	}
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
 	if ((cmd->fs.flow_type & FLOW_EXT)) {
 		if (cmd->fs.m_ext.vlan_etype ||
 		    !(cmd->fs.m_ext.vlan_tci == 0 ||
@@ -710,6 +719,7 @@ static int mlx4_en_validate_flow(struct net_device *dev,
 				return -EINVAL;
 		}
 	}
+#endif
 
 	return 0;
 }
@@ -724,6 +734,7 @@ static int mlx4_en_ethtool_add_mac_rule(struct ethtool_rxnfc *cmd,
 
 	spec_l2->id = MLX4_NET_TRANS_RULE_ID_ETH;
 	memcpy(spec_l2->eth.dst_mac_msk, &mac_msk, ETH_ALEN);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
 	if ((cmd->fs.flow_type & ~FLOW_EXT) != ETHER_FLOW)
 		memcpy(spec_l2->eth.dst_mac, &be_mac, ETH_ALEN);
 
@@ -731,7 +742,9 @@ static int mlx4_en_ethtool_add_mac_rule(struct ethtool_rxnfc *cmd,
 		spec_l2->eth.vlan_id = cmd->fs.h_ext.vlan_tci;
 		spec_l2->eth.vlan_id_msk = cpu_to_be16(0xfff);
 	}
-
+#else
+	memcpy(spec_l2->eth.dst_mac, &be_mac, ETH_ALEN);
+#endif
 	list_add_tail(&spec_l2->list, rule_list_h);
 
 	return err;
@@ -850,14 +863,17 @@ static int mlx4_en_ethtool_to_net_trans_rule(struct net_device *dev,
 					     struct list_head *rule_list_h)
 {
 	int err;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
 	struct ethhdr *eth_spec;
 	struct mlx4_spec_list *spec_l2;
+#endif
 	struct mlx4_en_priv *priv = netdev_priv(dev);
 
 	err = mlx4_en_validate_flow(dev, cmd);
 	if (err)
 		return err;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
 	switch (cmd->fs.flow_type & ~FLOW_EXT) {
 	case ETHER_FLOW:
 		spec_l2 = kzalloc(sizeof(*spec_l2), GFP_KERNEL);
@@ -872,6 +888,9 @@ static int mlx4_en_ethtool_to_net_trans_rule(struct net_device *dev,
 		if (eth_spec->h_proto)
 			spec_l2->eth.ether_type_enable = 1;
 		break;
+#else
+	switch (cmd->fs.flow_type) {
+#endif
 	case IP_USER_FLOW:
 		err = add_ip_rule(priv, cmd, rule_list_h);
 		break;
@@ -1024,8 +1043,13 @@ static int mlx4_en_get_num_flows(struct mlx4_en_priv *priv)
 
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
 static int mlx4_en_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
 			     u32 *rule_locs)
+#else
+static int mlx4_en_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
+			     void *rule_locs)
+#endif
 {
 	struct mlx4_en_priv *priv = netdev_priv(dev);
 	struct mlx4_en_dev *mdev = priv->mdev;
@@ -1052,8 +1076,13 @@ static int mlx4_en_get_rxnfc(struct net_device *dev, struct ethtool_rxnfc *cmd,
 	case ETHTOOL_GRXCLSRLALL:
 		while ((!err || err == -ENOENT) && priority < cmd->rule_cnt) {
 			err = mlx4_en_get_flow(dev, cmd, i);
-			if (!err)
+			if (!err) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,0,0))
 				rule_locs[priority++] = i;
+#else
+				((u32 *)(rule_locs))[priority++] = i;
+#endif
+			}
 			i++;
 		}
 		err = 0;
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 9865349..f943d72 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -47,6 +47,7 @@
 #include "mlx4_en.h"
 #include "en_port.h"
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 static int mlx4_en_setup_tc(struct net_device *dev, u8 up)
 {
 	struct mlx4_en_priv *priv = netdev_priv(dev);
@@ -67,6 +68,7 @@ static int mlx4_en_setup_tc(struct net_device *dev, u8 up)
 
 	return 0;
 }
+#endif
 
 #ifdef CONFIG_RFS_ACCEL
 
@@ -464,18 +466,30 @@ static void mlx4_en_clear_list(struct net_device *dev)
 static void mlx4_en_cache_mclist(struct net_device *dev)
 {
 	struct mlx4_en_priv *priv = netdev_priv(dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	struct netdev_hw_addr *ha;
+#else
+	struct dev_mc_list *mclist;
+#endif
 	struct mlx4_en_mc_list *tmp;
 
 	mlx4_en_clear_list(dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 	netdev_for_each_mc_addr(ha, dev) {
+#else
+	for (mclist = dev->mc_list; mclist; mclist = mclist->next) {
+#endif
 		tmp = kzalloc(sizeof(struct mlx4_en_mc_list), GFP_ATOMIC);
 		if (!tmp) {
 			en_err(priv, "failed to allocate multicast list\n");
 			mlx4_en_clear_list(dev);
 			return;
 		}
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
 		memcpy(tmp->addr, ha->addr, ETH_ALEN);
+#else
+		memcpy(tmp->addr, mclist->dmi_addr, ETH_ALEN);
+#endif
 		list_add_tail(&tmp->list, &priv->mc_list);
 	}
 }
@@ -1609,6 +1623,7 @@ static int mlx4_en_ioctl(struct net_device *dev, struct ifreq *ifr, int cmd)
 	}
 }
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 static int mlx4_en_set_features(struct net_device *netdev,
 		netdev_features_t features)
 {
@@ -1623,6 +1638,7 @@ static int mlx4_en_set_features(struct net_device *netdev,
 	return 0;
 
 }
+#endif
 
 static int mlx4_en_set_vf_mac(struct net_device *dev, int queue, u8 *mac)
 {
@@ -1669,8 +1685,10 @@ static const struct net_device_ops mlx4_netdev_ops = {
 #ifdef CONFIG_NET_POLL_CONTROLLER
 	.ndo_poll_controller	= mlx4_en_netpoll,
 #endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	.ndo_set_features	= mlx4_en_set_features,
 	.ndo_setup_tc		= mlx4_en_setup_tc,
+#endif
 #ifdef CONFIG_RFS_ACCEL
 	.ndo_rx_flow_steer	= mlx4_en_filter_rfs,
 #endif
@@ -1819,6 +1837,7 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	/*
 	 * Set driver features
 	 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	dev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | NETIF_F_GRO;
 	if (mdev->LSO_support)
 		dev->hw_features |= NETIF_F_TSO | NETIF_F_TSO6;
@@ -1834,7 +1853,24 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	if (mdev->dev->caps.steering_mode ==
 	    MLX4_STEERING_MODE_DEVICE_MANAGED)
 		dev->hw_features |= NETIF_F_NTUPLE;
-
+#else
+       dev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
+       if (mdev->LSO_support)
+               dev->features |= NETIF_F_TSO | NETIF_F_TSO6;
+
+       dev->vlan_features = dev->features;
+
+       dev->features |= NETIF_F_RXCSUM | NETIF_F_RXHASH;
+       dev->features |= NETIF_F_HIGHDMA |
+                       NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX |
+                       NETIF_F_HW_VLAN_FILTER;
+       dev->features |= NETIF_F_LOOPBACK;
+
+       if (mdev->dev->caps.steering_mode ==
+           MLX4_STEERING_MODE_DEVICE_MANAGED)
+               dev->features |= NETIF_F_NTUPLE;
+#endif
+	
 	mdev->pndev[port] = dev;
 
 	netif_carrier_off(dev);
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_tx.c b/drivers/net/ethernet/mellanox/mlx4/en_tx.c
index 74dd914..067ba04 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_tx.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_tx.c
@@ -594,7 +594,11 @@ u16 mlx4_en_select_queue(struct net_device *dev, struct sk_buff *skb)
 	u16 rings_p_up = priv->mdev->profile.num_tx_rings_p_up;
 	u8 up = 0;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 	if (dev->num_tc)
+#else
+	if (netdev_get_num_tc(dev))
+#endif
 		return skb_tx_hash(dev, skb);
 
 	if (vlan_tx_tag_present(skb))
@@ -695,8 +699,13 @@ netdev_tx_t mlx4_en_xmit(struct sk_buff *skb, struct net_device *dev)
 	 * set flag for further reference
 	 */
 	if (ring->hwtstamp_tx_type == HWTSTAMP_TX_ON &&
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37)
 	    skb_shinfo(skb)->tx_flags & SKBTX_HW_TSTAMP) {
 		skb_shinfo(skb)->tx_flags |= SKBTX_IN_PROGRESS;
+#else
+	    skb_shinfo(skb)->tx_flags.flags & SKBTX_HW_TSTAMP) {
+		skb_shinfo(skb)->tx_flags.flags |= SKBTX_IN_PROGRESS;
+#endif
 		tx_info->ts_requested = 1;
 	}
 
diff --git a/drivers/net/ethernet/mellanox/mlx4/eq.c b/drivers/net/ethernet/mellanox/mlx4/eq.c
index afd29a6..74954d5 100644
--- a/drivers/net/ethernet/mellanox/mlx4/eq.c
+++ b/drivers/net/ethernet/mellanox/mlx4/eq.c
@@ -39,7 +39,9 @@
 #include <linux/dma-mapping.h>
 
 #include <linux/mlx4/cmd.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 #include <linux/cpu_rmap.h>
+#endif
 
 #include "mlx4.h"
 #include "fw.h"
@@ -1308,8 +1310,12 @@ int mlx4_test_interrupts(struct mlx4_dev *dev)
 }
 EXPORT_SYMBOL(mlx4_test_interrupts);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 int mlx4_assign_eq(struct mlx4_dev *dev, char *name, struct cpu_rmap *rmap,
 		   int *vector)
+#else
+int mlx4_assign_eq(struct mlx4_dev *dev, char* name, int * vector)
+#endif
 {
 
 	struct mlx4_priv *priv = mlx4_priv(dev);
@@ -1323,6 +1329,7 @@ int mlx4_assign_eq(struct mlx4_dev *dev, char *name, struct cpu_rmap *rmap,
 			snprintf(priv->eq_table.irq_names +
 					vec * MLX4_IRQNAME_SIZE,
 					MLX4_IRQNAME_SIZE, "%s", name);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 #ifdef CONFIG_RFS_ACCEL
 			if (rmap) {
 				err = irq_cpu_rmap_add(rmap,
@@ -1331,6 +1338,7 @@ int mlx4_assign_eq(struct mlx4_dev *dev, char *name, struct cpu_rmap *rmap,
 					mlx4_warn(dev, "Failed adding irq rmap\n");
 			}
 #endif
+#endif
 			err = request_irq(priv->eq_table.eq[vec].irq,
 					  mlx4_msi_x_interrupt, 0,
 					  &priv->eq_table.irq_names[vec<<5],
diff --git a/include/linux/mlx4/device.h b/include/linux/mlx4/device.h
index cbb0134..6597e06 100644
--- a/include/linux/mlx4/device.h
+++ b/include/linux/mlx4/device.h
@@ -36,7 +36,9 @@
 #include <linux/pci.h>
 #include <linux/completion.h>
 #include <linux/radix-tree.h>
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 #include <linux/cpu_rmap.h>
+#endif
 
 #include <linux/atomic.h>
 
@@ -1062,8 +1064,12 @@ int mlx4_query_diag_counters(struct mlx4_dev *mlx4_dev, int array_length,
 			     u32 counter_out[]);
 
 int mlx4_test_interrupts(struct mlx4_dev *dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
 int mlx4_assign_eq(struct mlx4_dev *dev, char *name, struct cpu_rmap *rmap,
 		   int *vector);
+#else
+int mlx4_assign_eq(struct mlx4_dev *dev, char* name , int* vector);
+#endif
 void mlx4_release_eq(struct mlx4_dev *dev, int vec);
 
 int mlx4_wol_read(struct mlx4_dev *dev, u64 *config, int port);
-- 
1.7.8.2

