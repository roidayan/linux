From e5886e383c39c182cca5183017c64ad482caebab Mon Sep 17 00:00:00 2001
From: Eugenia Emantayev <eugenia@mellanox.co.il>
Date: Mon, 8 Apr 2013 12:49:37 +0300
Subject: [PATCH] BACKPORT: mlx4_en enable LRO for kernels < 3.1

Signed-off-by: Eugenia Emantayev <eugenia@mellanox.co.il>
---
 drivers/net/ethernet/mellanox/mlx4/en_ethtool.c |   27 +++++++++++++++++++++++-
 drivers/net/ethernet/mellanox/mlx4/en_netdev.c  |   10 +++
 drivers/net/ethernet/mellanox/mlx4/en_rx.c      |   98 ++++++++++++++++++++++-
 drivers/net/ethernet/mellanox/mlx4/mlx4_en.h    |   22 ++++++++-
 4 files changed, 128 insertions(+), 1 deletions(-)

diff --git a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@ -201,7 +201,11 @@ static const char main_strings[][ETH_GSTRING_LEN] = {
 	"tx_heartbeat_errors", "tx_window_errors",
 
 	/* port statistics */
-	"tso_packets",
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+	"lro_aggregated", "lro_flushed", "lro_no_desc", "tso_packets",
+#else
+	"tso_packets",
+#endif
 	"queue_stopped", "wake_queue", "tx_timeout", "rx_alloc_failed",
 	"rx_csum_good", "rx_csum_none", "tx_chksum_offload",
 
@@ -329,6 +329,23 @@ int mlx4_en_get_sset_count(struct net_device *dev, int sset)
 	}
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+static void mlx4_en_update_lro_stats(struct mlx4_en_priv *priv)
+{
+	int i;
+
+	priv->port_stats.lro_aggregated = 0;
+	priv->port_stats.lro_flushed = 0;
+	priv->port_stats.lro_no_desc = 0;
+
+	for (i = 0; i < priv->rx_ring_num; i++) {
+		priv->port_stats.lro_aggregated += priv->rx_ring[i]->lro.lro_mgr.stats.aggregated;
+		priv->port_stats.lro_flushed += priv->rx_ring[i]->lro.lro_mgr.stats.flushed;
+		priv->port_stats.lro_no_desc += priv->rx_ring[i]->lro.lro_mgr.stats.no_desc;
+	}
+}
+#endif
+
 void mlx4_en_get_ethtool_stats(struct net_device *dev,
 		struct ethtool_stats *stats, u64 *data)
 {
@@ -341,6 +358,10 @@ void mlx4_en_get_ethtool_stats(struct net_device *dev,
 
 	spin_lock_bh(&priv->stats_lock);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+	mlx4_en_update_lro_stats(priv);
+#endif
+
 	if (!(priv->stats_bitmap)) {
 		for (i = 0; i < NUM_MAIN_STATS; i++)
 			data[index++] =
@@ -1460,6 +1460,10 @@ const struct ethtool_ops mlx4_en_ethtool_ops = {
 	.set_pauseparam = mlx4_en_set_pauseparam,
 	.get_ringparam = mlx4_en_get_ringparam,
 	.set_ringparam = mlx4_en_set_ringparam,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+	.get_flags = ethtool_op_get_flags,
+	.set_flags = ethtool_op_set_flags,
+#endif
 	.get_rxnfc = mlx4_en_get_rxnfc,
 	.set_rxnfc = mlx4_en_set_rxnfc,
 #ifndef CONFIG_COMPAT_INDIR_SETTING
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -2583,7 +2583,12 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	 * Set driver features
 	 */
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39))
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+	dev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+		NETIF_F_GRO | NETIF_F_LRO;
+#else
 	dev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | NETIF_F_GRO;
+#endif
 	if (mdev->LSO_support)
 		dev->hw_features |= NETIF_F_TSO | NETIF_F_TSO6;
 
@@ -2609,7 +2614,12 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 #endif
 
 #else
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+	dev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+		NETIF_F_GRO | NETIF_F_LRO;
+#else
 	dev->features = NETIF_F_SG | NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM | NETIF_F_GRO;
+#endif
 	if (mdev->LSO_support)
 		dev->features |= NETIF_F_TSO | NETIF_F_TSO6;
 
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_rx.c b/drivers/net/ethernet/mellanox/mlx4/en_rx.c
index xxxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/mellanox/mlx4/en_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_rx.c
@@ -176,6 +176,53 @@ static void mlx4_en_free_rx_buf(struct mlx4_en_priv *priv,
 	}
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+static int mlx4_en_get_skb_hdr(struct sk_buff *skb,
+			       void **iphdr, void **tcph,
+			       u64 *hdr_flags, void *priv)
+{
+	unsigned int ip_len;
+	struct iphdr *iph;
+
+	if (unlikely(skb->protocol != htons(ETH_P_IP)))
+		return -1;
+
+	if (unlikely(skb->ip_summed != CHECKSUM_UNNECESSARY))
+		return -1;
+
+	/* Check for non-TCP packet */
+	skb_reset_network_header(skb);
+	iph = ip_hdr(skb);
+	if (iph->protocol != IPPROTO_TCP)
+		return -1;
+
+	ip_len = ip_hdrlen(skb);
+	skb_set_transport_header(skb, ip_len);
+	*tcph = tcp_hdr(skb);
+
+	/* check if IP header and TCP header are complete */
+	if (ntohs(iph->tot_len) < ip_len + tcp_hdrlen(skb))
+		return -1;
+
+	*hdr_flags = LRO_IPV4 | LRO_TCP;
+	*iphdr = iph;
+
+	return 0;
+}
+
+static void mlx4_en_lro_init(struct mlx4_en_rx_ring *ring,
+			    struct mlx4_en_priv *priv)
+{
+	ring->lro.lro_mgr.max_aggr		= MLX4_EN_LRO_MAX_AGGR;
+	ring->lro.lro_mgr.max_desc		= MLX4_EN_LRO_MAX_DESC;
+	ring->lro.lro_mgr.lro_arr		= ring->lro.lro_desc;
+	ring->lro.lro_mgr.get_skb_header	= mlx4_en_get_skb_hdr;
+	ring->lro.lro_mgr.features		= LRO_F_NAPI;
+	ring->lro.lro_mgr.dev			= priv->dev;
+	ring->lro.lro_mgr.ip_summed_aggr	= CHECKSUM_UNNECESSARY;
+}
+
+#endif
 int mlx4_en_create_rx_ring(struct mlx4_en_priv *priv,
 			   struct mlx4_en_rx_ring **pring,
 			   u32 size, int node)
@@ -231,6 +278,9 @@ int mlx4_en_create_rx_ring(struct mlx4_en_priv *priv,
 	ring->buf = ring->wqres.buf.direct.buf;
 
 	ring->hwtstamp_rx_filter = priv->hwtstamp_config.rx_filter;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+	mlx4_en_lro_init(ring, priv);
+#endif
 
 	*pring = ring;
 	return 0;
@@ -399,6 +449,31 @@ out_loopback:
 	dev_kfree_skb_any(skb);
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+static inline int mlx4_en_can_lro(__be16 status)
+{
+	static __be16 status_all;
+	static __be16 status_ipv4_ipok_tcp;
+
+	status_all		= cpu_to_be16(
+					MLX4_CQE_STATUS_IPV4    |
+					MLX4_CQE_STATUS_IPV4F   |
+					MLX4_CQE_STATUS_IPV6    |
+					MLX4_CQE_STATUS_IPV4OPT |
+					MLX4_CQE_STATUS_TCP     |
+					MLX4_CQE_STATUS_UDP     |
+					MLX4_CQE_STATUS_IPOK);
+
+	status_ipv4_ipok_tcp	= cpu_to_be16(
+					MLX4_CQE_STATUS_IPV4    |
+					MLX4_CQE_STATUS_IPOK    |
+					MLX4_CQE_STATUS_TCP);
+
+	status &= status_all;
+	return status == status_ipv4_ipok_tcp;
+}
+#endif
+
 int mlx4_en_process_rx_cq(struct net_device *dev,
 			  struct mlx4_en_cq *cq,
 			  int budget)
@@ -496,6 +496,9 @@ int mlx4_en_process_rx_cq(struct net_device *dev,
 	int size = cq->size;
 	struct mlx4_cqe *buf = cq->buf;
 	u64 timestamp;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+	int csum_pass = 0;
+#endif
 
 	if (!priv->port_up)
 		return 0;
@@ -582,6 +585,9 @@ int mlx4_en_process_rx_cq(struct net_device *dev,
 		if (likely((dev->features & NETIF_F_RXCSUM) &&
 			   (cqe->status & cpu_to_be16(MLX4_CQE_STATUS_IPOK)) &&
 			   (cqe->checksum == cpu_to_be16(0xffff)))) {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+			csum_pass = 1;
+#endif
 			ring->csum_ok++;
 			skb->ip_summed = CHECKSUM_UNNECESSARY;
 		} else {
@@ -593,6 +599,14 @@ int mlx4_en_process_rx_cq(struct net_device *dev,
 #if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
 		    priv->vlgrp && (be32_to_cpu(cqe->vlan_my_qpn) &
 				    MLX4_CQE_VLAN_PRESENT_MASK)) {
+			if (csum_pass && (dev->features & NETIF_F_LRO) &&
+			    mlx4_en_can_lro(cqe->status)) {
+				lro_vlan_hwaccel_receive_skb(&ring->lro.lro_mgr,
+							     skb, priv->vlgrp,
+							     be16_to_cpu(cqe->sl_vid),
+							     NULL);
+				goto next;
+			}
 			vlan_gro_receive(&cq->napi, priv->vlgrp,
 					 be16_to_cpu(cqe->sl_vid),
 					 skb);
@@ -533,6 +619,13 @@ int mlx4_en_process_rx_cq(struct net_device *dev,
 					       timestamp);
 		}
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+		if (csum_pass && (dev->features & NETIF_F_LRO) &&
+		    mlx4_en_can_lro(cqe->status)) {
+			lro_receive_skb(&ring->lro.lro_mgr, skb, NULL);
+			goto next;
+		}
+#endif
 		/* Push it up the stack */
 		napi_gro_receive(&cq->napi, skb);
 
@@ -548,6 +641,10 @@ next:
 	}
 
 out:
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+	if (dev->features & NETIF_F_LRO)
+		lro_flush_all(&priv->rx_ring[cq->ring]->lro.lro_mgr);
+#endif
 	AVG_PERF_COUNTER(priv->pstats.rx_coal_avg, polled);
 	mcq->cons_index = cons_index;
 	mlx4_cq_set_ci(mcq);
@@ -558,7 +655,6 @@ out:
 	return polled;
 }
 
-
 void mlx4_en_rx_irq(struct mlx4_cq *mcq)
 {
 	struct mlx4_en_cq *cq = container_of(mcq, struct mlx4_en_cq, mcq);
diff --git a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
@@ -46,6 +46,9 @@
 #include <linux/dcbnl.h>
 #endif
 #include <linux/cpu_rmap.h>
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+#include <linux/inet_lro.h>
+#endif
 
 #include <linux/mlx4/device.h>
 #include <linux/mlx4/qp.h>
@@ -259,6 +262,17 @@ struct mlx4_en_tx_desc {
 #define MLX4_EN_TX_BUDGET 64
 #define MLX4_EN_RX_BUDGET 64
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+/* LRO defines for MLX4_EN */
+#define MLX4_EN_LRO_MAX_DESC	32
+#define MLX4_EN_LRO_MAX_AGGR	64
+
+struct mlx4_en_lro {
+	struct net_lro_mgr	lro_mgr;
+	struct net_lro_desc	lro_desc[MLX4_EN_LRO_MAX_DESC];
+};
+
+#endif
 #define MLX4_EN_CX3_LOW_ID	0x1000
 #define MLX4_EN_CX3_HIGH_ID	0x1005
 
@@ -320,6 +334,9 @@ struct mlx4_en_rx_ring {
 	unsigned long csum_ok;
 	unsigned long csum_none;
 	int hwtstamp_rx_filter;
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+	struct mlx4_en_lro lro;
+#endif
 };
 
 struct mlx4_en_cq {
@@ -428,6 +428,11 @@ struct mlx4_en_pkt_stats {
 };
 
 struct mlx4_en_port_stats {
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+	unsigned long lro_aggregated;
+	unsigned long lro_flushed;
+	unsigned long lro_no_desc;
+#endif
 	unsigned long tso_packets;
 	unsigned long queue_stopped;
 	unsigned long wake_queue;
@@ -436,7 +439,11 @@ struct mlx4_en_port_stats {
 	unsigned long rx_chksum_good;
 	unsigned long rx_chksum_none;
 	unsigned long tx_chksum_offload;
-#define NUM_PORT_STATS		8
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,1,0))
+#define NUM_PORT_STATS		11
+#else
+#define NUM_PORT_STATS		8
+#endif
 };
 
 struct mlx4_en_perf_stats {
-- 
1.7.1

