From afa0cacd548839b6192f5c1b2524bb69d91f27b9 Mon Sep 17 00:00:00 2001
From: Yan Burman <yanb@mellanox.com>
Date: Thu, 24 Jan 2013 15:17:47 +0200
Subject: [PATCH] BACKPORT: net/mlx4_en fdb_add for kernel < 3.5

Signed-off-by: Yan Burman <yanb@mellanox.com>
---
 drivers/net/ethernet/mellanox/mlx4/en_netdev.c | 183 +++++++++++++++++++++++++
 1 file changed, 183 insertions(+)

diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index 8454b88..3db3595 100644
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -1878,6 +1878,169 @@ err:
 	return -ENOMEM;
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0))
+static int dev_uc_add_excl(struct net_device *dev, unsigned char *addr)
+{
+	struct netdev_hw_addr *ha;
+	int err;
+
+	netif_addr_lock_bh(dev);
+	netdev_for_each_uc_addr(ha, dev) {
+		if (!memcmp(ha->addr, addr, dev->addr_len) &&
+		    ha->type == NETDEV_HW_ADDR_T_UNICAST) {
+			err = -EEXIST;
+			goto out;
+		}
+	}
+	netif_addr_unlock_bh(dev);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	return dev_uc_add(dev, addr);
+#else
+	return dev_unicast_add(dev, addr);
+#endif
+
+out:
+	netif_addr_unlock_bh(dev);
+	return err;
+}
+
+static int dev_mc_add_excl(struct net_device *dev, unsigned char *addr)
+{
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	struct netdev_hw_addr *ha;
+#else
+	struct dev_addr_list *ha;
+#endif
+	int err;
+
+	netif_addr_lock_bh(dev);
+	netdev_for_each_mc_addr(ha, dev) {
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+		if (!memcmp(ha->addr, addr, dev->addr_len)) {
+#else
+		if (!memcmp(ha->da_addr, addr, dev->addr_len)) {
+#endif
+			err = -EEXIST;
+			goto out;
+		}
+	}
+	netif_addr_lock_bh(dev);
+
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	return dev_mc_add(dev, addr);
+#else
+	return dev_mc_add(dev, addr, ETH_ALEN, true);
+#endif
+
+out:
+	netif_addr_unlock_bh(dev);
+	return err;
+}
+
+static ssize_t mlx4_en_show_fdb(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	struct net_device *netdev = to_net_dev(dev);
+	ssize_t len = 0;
+	struct netdev_hw_addr *ha;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+	struct netdev_hw_addr *mc;
+#else
+	struct dev_addr_list *mc;
+#endif
+
+	netif_addr_lock_bh(netdev);
+
+	netdev_for_each_uc_addr(ha, netdev) {
+		len += sprintf(&buf[len], "%02x:%02x:%02x:%02x:%02x:%02x\n",
+				ha->addr[0], ha->addr[1], ha->addr[2],
+				ha->addr[3], ha->addr[4], ha->addr[5]);
+	}
+
+	netdev_for_each_mc_addr(mc, netdev) {
+		len += sprintf(&buf[len], "%02x:%02x:%02x:%02x:%02x:%02x\n",
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+				mc->addr[0], mc->addr[1], mc->addr[2],
+				mc->addr[3], mc->addr[4], mc->addr[5]);
+#else
+				mc->da_addr[0], mc->da_addr[1], mc->da_addr[2],
+				mc->da_addr[3], mc->da_addr[4], mc->da_addr[5]);
+#endif
+	}
+
+	netif_addr_unlock_bh(netdev);
+
+	return len;
+}
+
+static ssize_t mlx4_en_set_fdb(struct device *dev,
+			       struct device_attribute *attr,
+			       const char *buf, size_t count)
+{
+	struct net_device *netdev = to_net_dev(dev);
+	struct mlx4_en_priv *priv = netdev_priv(netdev);
+	unsigned char mac[ETH_ALEN];
+	unsigned int tmp[ETH_ALEN];
+	int add = 0;
+	int err, i;
+
+	if (count < sizeof("-01:02:03:04:05:06"))
+		return -EINVAL;
+
+	switch (buf[0]) {
+	case '-':
+		break;
+	case '+':
+		add = 1;
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = sscanf(&buf[1], "%02x:%02x:%02x:%02x:%02x:%02x",
+		     &tmp[0], &tmp[1], &tmp[2], &tmp[3], &tmp[4], &tmp[5]);
+
+	if (err != ETH_ALEN)
+		return -EINVAL;
+
+	for (i = 0; i < ETH_ALEN; ++i)
+		mac[i] = tmp[i] & 0xff;
+
+	rtnl_lock();
+	if (is_unicast_ether_addr(mac)) {
+		if (add)
+			err = dev_uc_add_excl(netdev, mac);
+		else
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+			err = dev_uc_del(netdev, mac);
+#else
+			err = dev_unicast_delete(netdev, mac);
+#endif
+	} else if (is_multicast_ether_addr(mac)) {
+		if (add)
+			err = dev_mc_add_excl(netdev, mac);
+		else
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35))
+			err = dev_mc_del(netdev, mac);
+#else
+			err = dev_mc_delete(netdev, mac, ETH_ALEN, true);
+#endif
+	} else {
+		rtnl_unlock();
+		return -EINVAL;
+	}
+	rtnl_unlock();
+
+	en_dbg(DRV, priv, "Port:%d: %s %pM\n", priv->port,
+	       (add ? "adding" : "removing"), mac);
+
+	return err ? err : count;
+}
+
+static DEVICE_ATTR(fdb, S_IRUGO | 002, mlx4_en_show_fdb, mlx4_en_set_fdb);
+#endif
 
 void mlx4_en_destroy_netdev(struct net_device *dev)
 {
@@ -1911,6 +2074,10 @@ void mlx4_en_destroy_netdev(struct net_device *dev)
 	kfree(priv->tx_ring);
 	kfree(priv->tx_cq);
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0))
+	if (mlx4_is_mfunc(priv->mdev->dev))
+		device_remove_file(&dev->dev, &dev_attr_fdb);
+#endif
 	free_netdev(dev);
 }
 
@@ -2053,6 +2220,7 @@ static int mlx4_en_set_vf_spoofchk(struct net_device *dev, int vf, bool setting)
 }
 #endif
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0))
 static int mlx4_en_fdb_add(struct ndmsg *ndm, struct nlattr *tb[],
 			   struct net_device *dev,
 			   const unsigned char *addr, u16 flags)
@@ -2124,6 +2292,7 @@ static int mlx4_en_fdb_dump(struct sk_buff *skb,
 
 	return idx;
 }
+#endif
 
 static const struct net_device_ops mlx4_netdev_ops = {
 	.ndo_open		= mlx4_en_open,
@@ -2152,9 +2321,11 @@ static const struct net_device_ops mlx4_netdev_ops = {
 #ifdef CONFIG_RFS_ACCEL
 	.ndo_rx_flow_steer	= mlx4_en_filter_rfs,
 #endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0))
 	.ndo_fdb_add		= mlx4_en_fdb_add,
 	.ndo_fdb_del		= mlx4_en_fdb_del,
 	.ndo_fdb_dump		= mlx4_en_fdb_dump,
+#endif
 };
 
 static const struct net_device_ops mlx4_netdev_ops_master = {
@@ -2190,9 +2361,11 @@ static const struct net_device_ops mlx4_netdev_ops_master = {
 #ifdef CONFIG_RFS_ACCEL
 	.ndo_rx_flow_steer	= mlx4_en_filter_rfs,
 #endif
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0))
 	.ndo_fdb_add		= mlx4_en_fdb_add,
 	.ndo_fdb_del		= mlx4_en_fdb_del,
 	.ndo_fdb_dump		= mlx4_en_fdb_dump,
+#endif
 };
 
 int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
@@ -2405,6 +2578,16 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	}
 	priv->registered = 1;
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3, 5, 0))
+	if (mlx4_is_mfunc(priv->mdev->dev)) {
+		err = device_create_file(&dev->dev, &dev_attr_fdb);
+		if (err) {
+			en_err(priv, "Sysfs registration failed for port %d\n", port);
+			goto out;
+		}
+	}
+#endif
+
 	en_warn(priv, "Using %d TX rings\n", prof->tx_ring_num);
 	en_warn(priv, "Using %d RX rings\n", prof->rx_ring_num);
 
-- 
1.7.11.3

