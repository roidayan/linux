From: Yishai Hadas <yishaih@mellanox.com>
Subject: [PATCH] BACKPORT: mlx4_en for SLES11SP1

Change-Id: I3cacb226334d26d7225ab994783858690660821b
Signed-off-by: Vladimir Sokolovsky <vlad@mellanox.com>
Signed-off-by: Yishai Hadas <yishaih@mellanox.com>
---
 drivers/net/ethernet/mellanox/mlx4/Makefile       |    2 +
 drivers/net/ethernet/mellanox/mlx4/en_ethtool.c   |    4 ++
 drivers/net/ethernet/mellanox/mlx4/en_main.c      |   10 ++++++
 drivers/net/ethernet/mellanox/mlx4/en_netdev.c    |   24 ++++++++++++++-
 drivers/net/ethernet/mellanox/mlx4/en_resources.c |    6 ++++
 drivers/net/ethernet/mellanox/mlx4/en_rx.c        |   12 +++++++
 drivers/net/ethernet/mellanox/mlx4/en_tx.c        |   23 ++++++++++++++
 drivers/net/ethernet/mellanox/mlx4/mlx4_en.h      |   33 ++++++++++++++++++++-
 8 files changed, 112 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/mellanox/mlx4/Makefile b/drivers/net/ethernet/mellanox/mlx4/Makefile
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/mellanox/mlx4/Makefile
+++ b/drivers/net/ethernet/mellanox/mlx4/Makefile
@@ -11,4 +11,6 @@ mlx4_en-y := 	en_main.o en_tx.o en_rx.o en_ethtool.o en_port.o en_cq.o \
 
 mlx4_en-$(CONFIG_DEBUG_FS) += en_debugfs.o
 
+ifeq ($(CONFIG_COMPAT_DISABLE_DCB),)
 mlx4_en-$(CONFIG_MLX4_EN_DCB) += en_dcb_nl.o
+endif
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_ethtool.c
@@ -1210,10 +1210,14 @@ static int mlx4_en_set_channels(struct net_device *dev,
 		goto out;
 	}
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined (CONFIG_COMPAT_IS_NUM_TX_QUEUES)
 	netif_set_real_num_tx_queues(dev, priv->tx_ring_num - priv->tx_queue_num);
+#endif
 	netif_set_real_num_rx_queues(dev, priv->rx_ring_num);
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined (CONFIG_COMPAT_NEW_TX_RING_SCHEME)
 	mlx4_en_setup_tc(dev, MLX4_EN_NUM_UP);
+#endif
 
 	en_warn(priv, "Using %d TX rings\n", priv->tx_ring_num);
 	en_warn(priv, "Using %d RX rings\n", priv->rx_ring_num);
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_main.c b/drivers/net/ethernet/mellanox/mlx4/en_main.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/mellanox/mlx4/en_main.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_main.c
@@ -72,6 +72,7 @@ MLX4_EN_PARM_INT(pfctx, 0, "Priority based Flow Control policy on TX[7:0]."
 #define MAX_PFC_TX	0xff
 #define MAX_PFC_RX	0xff
 
+#ifndef CONFIG_COMPAT_DISABLE_VA_FORMAT_PRINT
 int en_print(const char *level, const struct mlx4_en_priv *priv,
 	     const char *format, ...)
 {
@@ -94,6 +95,7 @@ int en_print(const char *level, const struct mlx4_en_priv *priv,
 
 	return i;
 }
+#endif
 
 void mlx4_en_update_loopback_state(struct net_device *dev,
 				   netdev_features_t features)
@@ -123,8 +125,10 @@ static int mlx4_en_get_profile(struct mlx4_en_dev *mdev)
 	int i;
 
 	params->udp_rss = udp_rss;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined (CONFIG_COMPAT_NEW_TX_RING_SCHEME)
 	params->num_tx_rings_p_up = min_t(int, num_online_cpus(),
 			MLX4_EN_MAX_TX_RING_P_UP);
+#endif
 	if (params->udp_rss && !(mdev->dev->caps.flags
 					& MLX4_DEV_CAP_FLAG_UDP_RSS)) {
 		mlx4_warn(mdev, "UDP RSS is not supported on this device.\n");
@@ -141,9 +145,15 @@ static int mlx4_en_get_profile(struct mlx4_en_dev *mdev)
 		 * Double the number of default TX rings (for up = 0)
 		 * to enable splitting traffic by size
 		 */
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined (CONFIG_COMPAT_NEW_TX_RING_SCHEME)
 		params->prof[i].tx_queue_num = params->num_tx_rings_p_up;
 		params->prof[i].tx_ring_num = params->num_tx_rings_p_up *
 			MLX4_EN_NUM_UP + params->prof[i].tx_queue_num;
+#else
+		params->prof[i].tx_ring_num = MLX4_EN_NUM_TX_RINGS * 2 +
+			(!!pfcrx) * MLX4_EN_NUM_PPP_RINGS;
+		params->prof[i].tx_queue_num = MLX4_EN_NUM_TX_RINGS;
+#endif
 		params->prof[i].rss_rings = 0;
 	}
 
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_netdev.c
@@ -1500,8 +1500,11 @@ int mlx4_en_start_port(struct net_device *dev)
 
 		/* Configure ring */
 		tx_ring = priv->tx_ring[i];
-
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined (CONFIG_COMPAT_NEW_TX_RING_SCHEME)
 		err = mlx4_en_activate_tx_ring(priv, tx_ring, cq->mcq.cqn, up);
+#else
+		err = mlx4_en_activate_tx_ring(priv, tx_ring, cq->mcq.cqn);
+#endif
 		if (err) {
 			en_err(priv, "Failed allocating Tx ring\n");
 			mlx4_en_deactivate_cq(priv, cq);
@@ -2201,12 +2204,19 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	int i;
 	int err;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined(CONFIG_COMPAT_NEW_TX_RING_SCHEME)
 	dev = alloc_etherdev_mqs(sizeof(struct mlx4_en_priv),
 				 MAX_TX_RINGS, MAX_RX_RINGS);
+#else
+	dev = alloc_etherdev_mq(sizeof(struct mlx4_en_priv), max(MAX_TX_RINGS,
+								 MAX_RX_RINGS));
+#endif
 	if (dev == NULL)
 		return -ENOMEM;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined (CONFIG_COMPAT_IS_NUM_TX_QUEUES)
 	netif_set_real_num_tx_queues(dev, prof->tx_ring_num);
+#endif
 	netif_set_real_num_rx_queues(dev, prof->rx_ring_num);
 
 	SET_NETDEV_DEV(dev, &mdev->dev->pdev->dev);
@@ -2267,6 +2277,7 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	priv->last_ifq_jiffies = 0;
 	priv->if_counters_rx_errors = 0;
 	priv->if_counters_rx_no_buffer = 0;
+#ifndef CONFIG_COMPAT_DISABLE_DCB
 #ifdef CONFIG_MLX4_EN_DCB
 	if (!mlx4_is_slave(priv->mdev->dev) &&
 	    (mdev->dev->caps.flags & MLX4_DEV_CAP_FLAG_SET_PORT_ETH_SCHED)) {
@@ -2275,6 +2286,7 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 		dev->dcbnl_ops = &mlx4_en_dcbnl_ops;
 	}
 #endif
+#endif
 
 	for (i = 0; i < MLX4_EN_MAC_HASH_SIZE; ++i)
 		INIT_HLIST_HEAD(&priv->mac_hash[i]);
@@ -2328,7 +2340,9 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 	else
 		dev->netdev_ops = &mlx4_netdev_ops;
 	dev->watchdog_timeo = MLX4_EN_WATCHDOG_TIMEOUT;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined (CONFIG_COMPAT_IS_NUM_TX_QUEUES)
 	netif_set_real_num_tx_queues(dev, priv->tx_ring_num - priv->tx_queue_num);
+#endif
 	netif_set_real_num_rx_queues(dev, priv->rx_ring_num);
 
 	SET_ETHTOOL_OPS(dev, &mlx4_en_ethtool_ops);
@@ -2343,7 +2357,11 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 
 	dev->vlan_features = dev->hw_features;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
 	dev->hw_features |= NETIF_F_RXCSUM | NETIF_F_RXHASH;
+#else
+	dev->hw_features |= NETIF_F_RXCSUM;
+#endif
 	dev->features = dev->hw_features | NETIF_F_HIGHDMA |
 			NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX |
 			NETIF_F_HW_VLAN_FILTER;
@@ -2365,7 +2383,11 @@ int mlx4_en_init_netdev(struct mlx4_en_dev *mdev, int port,
 
 	dev->vlan_features = dev->features;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
 	dev->features |= NETIF_F_RXCSUM | NETIF_F_RXHASH;
+#else
+	dev->features |= NETIF_F_RXCSUM;
+#endif
 	dev->features |= NETIF_F_HIGHDMA |
 		NETIF_F_HW_VLAN_TX | NETIF_F_HW_VLAN_RX |
 		NETIF_F_HW_VLAN_FILTER;
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_resources.c b/drivers/net/ethernet/mellanox/mlx4/en_resources.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/mellanox/mlx4/en_resources.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_resources.c
@@ -39,7 +39,11 @@
 
 void mlx4_en_fill_qp_context(struct mlx4_en_priv *priv, int size, int stride,
 			     int is_tx, int rss, int qpn, int cqn,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined (CONFIG_COMPAT_NEW_TX_RING_SCHEME)
 			     int user_prio, struct mlx4_qp_context *context,
+#else
+			     struct mlx4_qp_context *context,
+#endif
 			     int disable_vstrip)
 {
 	struct mlx4_en_dev *mdev = priv->mdev;
@@ -58,10 +62,12 @@ void mlx4_en_fill_qp_context(struct mlx4_en_priv *priv, int size, int stride,
 	context->local_qpn = cpu_to_be32(qpn);
 	context->pri_path.ackto = 1 & 0x07;
 	context->pri_path.sched_queue = 0x83 | (priv->port - 1) << 6;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined (CONFIG_COMPAT_NEW_TX_RING_SCHEME)
 	if (user_prio >= 0) {
 		context->pri_path.sched_queue |= user_prio << 3;
 		context->pri_path.feup = 1 << 6;
 	}
+#endif
 	context->pri_path.counter_index = (u8)(priv->counter_index);
 	context->cqn_send = cpu_to_be32(cqn);
 	context->cqn_recv = cpu_to_be32(cqn);
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_rx.c b/drivers/net/ethernet/mellanox/mlx4/en_rx.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/mellanox/mlx4/en_rx.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_rx.c
@@ -498,8 +498,10 @@ int mlx4_en_process_rx_cq(struct net_device *dev,
 		skb->ip_summed = ip_summed;
 		skb_record_rx_queue(skb, cq->ring);
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,35)
 		if (dev->features & NETIF_F_RXHASH)
 			skb->rxhash = be32_to_cpu(cqe->immed_rss_invalid);
+#endif
 
 		if ((be32_to_cpu(cqe->vlan_my_qpn) &
 		     MLX4_CQE_VLAN_PRESENT_MASK) &&
@@ -608,8 +610,13 @@ static int mlx4_en_config_rss_qp(struct mlx4_en_priv *priv, int qpn,
 	qp->event = mlx4_en_sqp_event;
 
 	memset(context, 0, sizeof *context);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined (CONFIG_COMPAT_NEW_TX_RING_SCHEME)
 	mlx4_en_fill_qp_context(priv, ring->actual_size, ring->stride, 0, 0,
 				qpn, ring->cqn, -1, context, disable_vstrip);
+#else
+	mlx4_en_fill_qp_context(priv, ring->actual_size, ring->stride, 0, 0,
+				qpn, ring->cqn, context, disable_vstrip);
+#endif
 	context->db_rec_addr = cpu_to_be64(ring->wqres.db.dma);
 
 	/* Cancel FCS removal if FW allows */
@@ -706,8 +713,13 @@ int mlx4_en_config_rss_steer(struct mlx4_en_priv *priv)
 		goto rss_err;
 	}
 	rss_map->indir_qp.event = mlx4_en_sqp_event;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined (CONFIG_COMPAT_NEW_TX_RING_SCHEME)
 	mlx4_en_fill_qp_context(priv, 0, 0, 0, 1, priv->base_qpn,
 				priv->rx_ring[0]->cqn, -1, &context, 0);
+#else
+	mlx4_en_fill_qp_context(priv, 0, 0, 0, 1, priv->base_qpn,
+				priv->rx_ring[0]->cqn, &context, 0);
+#endif
 
 	if (!priv->prof->rss_rings || priv->prof->rss_rings > priv->rx_ring_num)
 		rss_rings = priv->rx_ring_num;
diff --git a/drivers/net/ethernet/mellanox/mlx4/en_tx.c b/drivers/net/ethernet/mellanox/mlx4/en_tx.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/mellanox/mlx4/en_tx.c
+++ b/drivers/net/ethernet/mellanox/mlx4/en_tx.c
@@ -206,7 +206,11 @@ void mlx4_en_create_tx_queues(struct mlx4_en_priv *priv)
 
 int mlx4_en_activate_tx_ring(struct mlx4_en_priv *priv,
 			     struct mlx4_en_tx_ring *ring,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined (CONFIG_COMPAT_NEW_TX_RING_SCHEME)
 			     int cq, int user_prio)
+#else
+			     int cq)
+#endif
 {
 	struct mlx4_en_dev *mdev = priv->mdev;
 	int err;
@@ -222,8 +226,13 @@ int mlx4_en_activate_tx_ring(struct mlx4_en_priv *priv,
 	ring->qp_state = MLX4_QP_STATE_RST;
 	ring->doorbell_qpn = ring->qp.qpn << 8;
 
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined (CONFIG_COMPAT_NEW_TX_RING_SCHEME)
 	mlx4_en_fill_qp_context(priv, ring->size, ring->stride, 1, 0, ring->qpn,
 				ring->cqn, user_prio, &ring->context, 0);
+#else
+	mlx4_en_fill_qp_context(priv, ring->size, ring->stride, 1, 0, ring->qpn,
+				ring->cqn, &ring->context, 0);
+#endif
 	if (ring->bf_enabled)
 		ring->context.usr_page = cpu_to_be32(ring->bf.uar->index);
 
@@ -661,6 +670,7 @@ static void build_inline_wqe(struct mlx4_en_tx_desc *tx_desc, struct sk_buff *sk
 u16 mlx4_en_select_queue(struct net_device *dev, struct sk_buff *skb)
 {
 	struct mlx4_en_priv *priv = netdev_priv(dev);
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined (CONFIG_COMPAT_NEW_TX_RING_SCHEME)
 	u16 rings_p_up = priv->num_tx_rings_p_up;
 	u8 up = 0;
 
@@ -675,6 +685,19 @@ u16 mlx4_en_select_queue(struct net_device *dev, struct sk_buff *skb)
 		up = vlan_tx_tag_get(skb) >> VLAN_PRIO_SHIFT;
 
 	return __skb_tx_hash(dev, skb, rings_p_up) + up * rings_p_up;
+#else /* (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined (CONFIG_COMPAT_NEW_TX_RING_SCHEME) */
+	u16 vlan_tag = 0;
+
+	/* If we support per priority flow control and the packet contains
+	 * a vlan tag, send the packet to the TX ring assigned to that priority
+	 */
+	if (priv->prof->rx_ppp && vlan_tx_tag_present(skb)) {
+		vlan_tag = vlan_tx_tag_get(skb);
+		return MLX4_EN_NUM_TX_RINGS + (vlan_tag >> 13);
+	}
+
+	return skb_tx_hash(dev, skb);
+#endif
 }
 
 static void mlx4_bf_copy(void __iomem *dst, unsigned long *src, unsigned bytecnt)
diff --git a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
+++ b/drivers/net/ethernet/mellanox/mlx4/mlx4_en.h
@@ -114,10 +114,17 @@
 
 #define MLX4_EN_MAX_TX_RING_P_UP	32
 #define MLX4_EN_NUM_UP			8
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37)) || defined (CONFIG_COMPAT_IS_NUM_TX_QUEUES)
 
 #define MAX_TX_RINGS			(MLX4_EN_MAX_TX_RING_P_UP * \
 					 (MLX4_EN_NUM_UP + 1))
 
+#else
+#define MLX4_EN_NUM_TX_RINGS           8
+#define MLX4_EN_NUM_PPP_RINGS          8
+#define MAX_TX_RINGS                   (MLX4_EN_NUM_TX_RINGS + MLX4_EN_NUM_PPP_RINGS)
+#endif
+
 #define MLX4_EN_DEF_TX_RING_SIZE	1024
 #define MLX4_EN_DEF_RX_RING_SIZE  	1024
 
@@ -415,6 +422,7 @@ struct mlx4_en_mc_list {
 	u64			reg_id;
 };
 
+#ifndef CONFIG_COMPAT_DISABLE_DCB
 #ifdef CONFIG_MLX4_EN_DCB
 /* Minimal TC BW - setting to 0 will block traffic */
 #define MLX4_EN_BW_MIN 1
@@ -423,6 +431,7 @@ struct mlx4_en_mc_list {
 #define MLX4_EN_TC_ETS 7
 
 #endif
+#endif
 
 struct ethtool_flow_id {
 	struct list_head list;
@@ -542,12 +551,14 @@ struct mlx4_en_priv {
 #define MLX4_EN_MAC_HASH_IDX 5
 	struct hlist_head mac_hash[MLX4_EN_MAC_HASH_SIZE];
 
+#ifndef CONFIG_COMPAT_DISABLE_DCB
 #ifdef CONFIG_MLX4_EN_DCB
 #define MLX4_EN_DCB_ENABLED   0x3
 	struct ieee_ets ets;
 	u16 maxrate[IEEE_8021QAZ_MAX_TCS];
 	u8 dcbx_cap;
 #endif
+#endif
 #ifdef CONFIG_RFS_ACCEL
 	spinlock_t filters_lock;
 	int last_filter_id;
@@ -608,7 +619,11 @@ void mlx4_en_destroy_tx_ring(struct mlx4_en_priv *priv,
 			     struct mlx4_en_tx_ring **pring);
 int mlx4_en_activate_tx_ring(struct mlx4_en_priv *priv,
 			     struct mlx4_en_tx_ring *ring,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined (CONFIG_COMPAT_NEW_TX_RING_SCHEME)
 			     int cq, int user_prio);
+#else
+			     int cq);
+#endif
 void mlx4_en_deactivate_tx_ring(struct mlx4_en_priv *priv,
 				struct mlx4_en_tx_ring *ring);
 void mlx4_en_create_tx_queues(struct mlx4_en_priv *priv);
@@ -628,7 +643,11 @@ int mlx4_en_process_rx_cq(struct net_device *dev,
 int mlx4_en_poll_rx_cq(struct napi_struct *napi, int budget);
 int mlx4_en_poll_tx_cq(struct napi_struct *napi, int budget);
 void mlx4_en_fill_qp_context(struct mlx4_en_priv *priv, int size, int stride,
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,39)) || defined (CONFIG_COMPAT_NEW_TX_RING_SCHEME)
 		int is_tx, int rss, int qpn, int cqn, int user_prio,
+#else
+		int is_tx, int rss, int qpn, int cqn,
+#endif
 		struct mlx4_qp_context *context, int disable_vstrip);
 void mlx4_en_sqp_event(struct mlx4_qp *qp, enum mlx4_event event);
 int mlx4_en_map_buffer(struct mlx4_buf *buf);
@@ -694,10 +713,22 @@ extern const struct ethtool_ops mlx4_en_ethtool_ops;
 /*
  * printk / logging functions
  */
-
+#ifdef CONFIG_COMPAT_DISABLE_VA_FORMAT_PRINT
+#define en_print(level, priv, format, arg...)                   \
+        {                                                       \
+        if ((priv)->registered)                                 \
+                printk(level "%s: %s: " format, DRV_NAME,       \
+                        (priv->dev)->name, ## arg);             \
+        else                                                    \
+                printk(level "%s: %s: Port %d: " format,        \
+                        DRV_NAME, dev_name(&priv->mdev->pdev->dev), \
+                        (priv)->port, ## arg);                  \
+        }
+#else
 __printf(3, 4)
 int en_print(const char *level, const struct mlx4_en_priv *priv,
 	     const char *format, ...);
+#endif
 
 #define en_dbg(mlevel, priv, format, arg...)			\
 do {								\
