From: Erez Shitrit <erezsh@mellanox.com>
Subject: BACKPORTS: net/eipoib ndo differences.

supports vlan functions, stats  structures.

Signed-off-by: Erez Shitrit <erezsh@mellanox.com>
---
 drivers/net/eipoib/eth_ipoib.h         |    6 ++
 drivers/net/eipoib/eth_ipoib_ethtool.c |   10 ++
 drivers/net/eipoib/eth_ipoib_main.c    |  150 ++++++++++++++++++++++++++++++--
 3 files changed, 160 insertions(+), 6 deletions(-)

diff --git a/drivers/net/eipoib/eth_ipoib.h b/drivers/net/eipoib/eth_ipoib.h
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/eipoib/eth_ipoib.h
+++ b/drivers/net/eipoib/eth_ipoib.h
@@ -180,7 +180,13 @@ struct parent {
 	s32      slave_cnt;
 	rwlock_t lock;
 	struct   port_stats port_stats;
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,35))
+	struct   net_device_stats stats;
+#endif
 	struct   list_head parent_list;
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3,0,0))
+	struct   vlan_group *vlgrp;
+#endif
 	u16      flags;
 	struct   workqueue_struct *wq;
 	s8       kill_timers;
diff --git a/drivers/net/eipoib/eth_ipoib_ethtool.c b/drivers/net/eipoib/eth_ipoib_ethtool.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/eipoib/eth_ipoib_ethtool.c
+++ b/drivers/net/eipoib/eth_ipoib_ethtool.c
@@ -100,12 +100,22 @@ static int parent_get_sset_count(struct net_device *parent_dev, int sset)
 	}
 }
 
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+static u32 eipoib_get_rx_csum(struct net_device *dev)
+{
+	return 1;
+}
+#endif
+
 static const struct ethtool_ops parent_ethtool_ops = {
 	.get_drvinfo		= parent_ethtool_get_drvinfo,
 	.get_strings		= parent_get_strings,
 	.get_ethtool_stats	= parent_get_ethtool_stats,
 	.get_sset_count		= parent_get_sset_count,
 	.get_link		= ethtool_op_get_link,
+#if (LINUX_VERSION_CODE < KERNEL_VERSION(3,0,0))
+	.get_rx_csum = eipoib_get_rx_csum,
+#endif
 };
 
 void parent_set_ethtool_ops(struct net_device *dev)
diff --git a/drivers/net/eipoib/eth_ipoib_main.c b/drivers/net/eipoib/eth_ipoib_main.c
index xxxxxxx..xxxxxxx xxxxxx
--- a/drivers/net/eipoib/eth_ipoib_main.c
+++ b/drivers/net/eipoib/eth_ipoib_main.c
@@ -63,6 +63,45 @@ static const char * const version =
 
 LIST_HEAD(parent_dev_list);
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3,0,0))
+static void eth_ipoib_vlan_rx_register(struct net_device *dev,
+				       struct vlan_group *grp)
+{
+	struct parent *parent = netdev_priv(dev);
+	write_lock(&parent->lock);
+	parent->vlgrp = grp;
+	write_unlock(&parent->lock);
+}
+
+static void eth_ipoib_vlan_rx_add_vid(struct net_device *dev,
+				      unsigned short vid)
+{
+}
+
+static void eth_ipoib_vlan_rx_kill_vid(struct net_device *dev,
+				       unsigned short vid)
+{
+}
+
+static void parent_del_vlans_from_slave(struct parent *parent,
+					struct net_device *slave_dev)
+{
+	const struct net_device_ops *slave_ops = slave_dev->netdev_ops;
+	
+	write_lock(&parent->lock);
+	
+	if (!(slave_dev->features & NETIF_F_HW_VLAN_FILTER) ||
+	    !(slave_ops->ndo_vlan_rx_kill_vid))
+		goto unreg;
+unreg:
+	if ((slave_dev->features & NETIF_F_HW_VLAN_RX) &&
+	    slave_ops->ndo_vlan_rx_register)
+		slave_ops->ndo_vlan_rx_register(slave_dev, NULL);
+	
+	write_unlock(&parent->lock);
+}
+#endif
+
 #if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32))
 /* name space sys/fs functions */
 int eipoib_net_id __read_mostly;
@@ -344,6 +383,7 @@ static void parent_detach_slave(struct parent *parent, struct slave *slave)
 	parent->slave_cnt--;
 }
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,38))
 static netdev_features_t parent_fix_features(struct net_device *dev,
 					     netdev_features_t features)
 {
@@ -373,6 +413,7 @@ static netdev_features_t parent_fix_features(struct net_device *dev,
 	read_unlock(&parent->lock);
 	return features;
 }
+#endif
 
 static int parent_compute_features(struct parent *parent)
 {
@@ -392,7 +433,9 @@ static int parent_compute_features(struct parent *parent)
 	/* gets the common features from all slaves */
 	parent_for_each_slave(parent, slave) {
 		features &= slave->dev->features;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(3,0,0))
 		hw_features &= slave->dev->hw_features;
+#endif
 	}
 
 	features = features | PARENT_VLAN_FEATURES;
@@ -402,12 +445,17 @@ static int parent_compute_features(struct parent *parent)
 
 	features &= hw_features;
 	features |= take;
-
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(3,0,0))
 	parent_dev->hw_features = hw_features;
+#endif
 	parent_dev->features = features;
 	parent_dev->vlan_features = parent_dev->features & ~PARENT_VLAN_FEATURES;
 done:
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(3,0,0))
 	pr_info("%s: %s: Features: 0x%llx\n",
+#else
+	pr_info("%s: %s: Features: 0x%lx\n",
+#endif
 		__func__, parent_dev->name, parent_dev->features);
 
 	return 0;
@@ -650,6 +698,10 @@ int parent_release_slave(struct net_device *parent_dev,
 	/* must do this from outside any spinlocks */
 	destroy_slave_symlinks(parent_dev, slave_dev);
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3,0,0))
+	parent_del_vlans_from_slave(parent, slave_dev);
+#endif
+
 	netdev_set_parent_master(slave_dev, NULL);
 
 	dev_close(slave_dev);
@@ -686,6 +738,9 @@ static int parent_release_all(struct net_device *parent_dev)
 
 		destroy_slave_symlinks(parent_dev, slave_dev);
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3,0,0))
+	parent_del_vlans_from_slave(parent, slave_dev);
+#endif
 		netdev_set_parent_master(slave_dev, NULL);
 
 		dev_close(slave_dev);
@@ -713,18 +768,27 @@ out:
 }
 
 /* -------------------------- Device entry points --------------------------- */
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35))
 static struct rtnl_link_stats64 *parent_get_stats(struct net_device *parent_dev,
 						  struct rtnl_link_stats64 *stats)
+#else
+static struct net_device_stats *parent_get_stats(struct net_device *parent_dev)
+#endif
 {
 	struct parent *parent = netdev_priv(parent_dev);
 	struct slave *slave;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35))
 	struct rtnl_link_stats64 temp;
-
 	memset(stats, 0, sizeof(*stats));
-
+#else
+	struct net_device_stats *stats = &parent->stats;
+	struct net_device_stats local_stats;
+	memset(&local_stats, 0, sizeof(struct net_device_stats));
+#endif
 	read_lock(&parent->lock);
 
 	parent_for_each_slave(parent, slave) {
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35))
 		const struct rtnl_link_stats64 *sstats =
 			dev_get_stats(slave->dev, &temp);
 
@@ -753,7 +817,38 @@ static struct rtnl_link_stats64 *parent_get_stats(struct net_device *parent_dev,
 		stats->tx_fifo_errors += sstats->tx_fifo_errors;
 		stats->tx_heartbeat_errors += sstats->tx_heartbeat_errors;
 		stats->tx_window_errors += sstats->tx_window_errors;
+#else
+		const struct net_device_stats *sstats = dev_get_stats(slave->dev);
+		local_stats.rx_packets += sstats->rx_packets;
+		local_stats.rx_bytes += sstats->rx_bytes;
+		local_stats.rx_errors += sstats->rx_errors;
+		local_stats.rx_dropped += sstats->rx_dropped;
+		
+		local_stats.tx_packets += sstats->tx_packets;
+		local_stats.tx_bytes += sstats->tx_bytes;
+		local_stats.tx_errors += sstats->tx_errors;
+		local_stats.tx_dropped += sstats->tx_dropped;
+		
+		local_stats.multicast += sstats->multicast;
+		local_stats.collisions += sstats->collisions;
+		
+		local_stats.rx_length_errors += sstats->rx_length_errors;
+		local_stats.rx_over_errors += sstats->rx_over_errors;
+		local_stats.rx_crc_errors += sstats->rx_crc_errors;
+		local_stats.rx_frame_errors += sstats->rx_frame_errors;
+		local_stats.rx_fifo_errors += sstats->rx_fifo_errors;
+		local_stats.rx_missed_errors += sstats->rx_missed_errors;
+		
+		local_stats.tx_aborted_errors += sstats->tx_aborted_errors;
+		local_stats.tx_carrier_errors += sstats->tx_carrier_errors;
+		local_stats.tx_fifo_errors += sstats->tx_fifo_errors;
+		local_stats.tx_heartbeat_errors += sstats->tx_heartbeat_errors;
+		local_stats.tx_window_errors += sstats->tx_window_errors;
+#endif
 	}
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,35))
+	memcpy(stats, &local_stats, sizeof(struct net_device_stats));
+#endif
 
 	read_unlock(&parent->lock);
 
@@ -1515,6 +1610,7 @@ static int parent_rx(struct sk_buff *skb, struct slave *slave)
 		skb = nskb;
 
 	vlan_tag = slave->vlan & 0xfff;
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,32))
 	if (vlan_tag) {
 		skb = __vlan_hwaccel_put_tag(skb, vlan_tag);
 		if (!skb) {
@@ -1529,7 +1625,21 @@ static int parent_rx(struct sk_buff *skb, struct slave *slave)
 		rc = napi_gro_receive(napi, skb);
 	else
 		rc = netif_receive_skb(skb);
-
+#else
+       if (vlan_tag && parent->vlgrp) {
+               if (napi)
+                       rc = vlan_gro_receive(napi, parent->vlgrp,
+                                             vlan_tag, skb);
+               else
+                       rc = vlan_hwaccel_rx(skb, parent->vlgrp,
+                                            vlan_tag);
+       } else {
+               if (napi)
+                       rc = napi_gro_receive(napi, skb);
+               else /* Called from CM no GRO also on mainline */
+                       rc = netif_receive_skb(skb);
+       }
+#endif
 
 	return rc;
 
@@ -1800,21 +1910,40 @@ static const struct net_device_ops parent_netdev_ops = {
 	.ndo_select_queue	= parent_select_q,
 	/* parnt mtu is min(slaves_mtus) */
 	.ndo_change_mtu		= NULL,
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,38))
 	.ndo_fix_features	= parent_fix_features,
+#endif
 	/*
 	 * initial mac address is randomized, can be changed
 	 * thru this func later
 	 */
 	.ndo_set_mac_address = eth_mac_addr,
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35))
 	.ndo_get_stats64 = parent_get_stats,
+#else
+	.ndo_get_stats = parent_get_stats,
+#endif
+
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(2,6,35))
 	.ndo_add_slave = parent_enslave,
 	.ndo_del_slave = parent_release_slave,
+#endif
+
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3,0,0))
+	.ndo_vlan_rx_register   = eth_ipoib_vlan_rx_register,
+	.ndo_vlan_rx_add_vid = eth_ipoib_vlan_rx_add_vid,
+	.ndo_vlan_rx_kill_vid = eth_ipoib_vlan_rx_kill_vid,
+#endif
 };
 
 static void parent_setup(struct net_device *parent_dev)
 {
 	struct parent *parent = netdev_priv(parent_dev);
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,35))
+	memset(&parent->stats, 0, sizeof(struct net_device_stats));
+#endif
 	/* initialize rwlocks */
 	rwlock_init(&parent->lock);
 	rwlock_init(&parent->emac_info_lock);
@@ -1833,12 +1962,17 @@ static void parent_setup(struct net_device *parent_dev)
 	/* mark the parent intf as pif (master of other vifs.) */
 	parent_dev->priv_flags = IFF_EIPOIB_PIF;
 
+#if (LINUX_VERSION_CODE > KERNEL_VERSION(3,0,0))
 	parent_dev->hw_features = NETIF_F_SG | NETIF_F_IP_CSUM |
 		NETIF_F_RXCSUM | NETIF_F_GRO | NETIF_F_TSO;
 
 	parent_dev->features = parent_dev->hw_features;
 	parent_dev->vlan_features = parent_dev->hw_features;
-
+#else
+	parent_dev->features = NETIF_F_SG | NETIF_F_IP_CSUM |
+		NETIF_F_GRO | NETIF_F_TSO;
+	parent_dev->vlan_features = parent_dev->features;
+#endif
 	parent_dev->features |= PARENT_VLAN_FEATURES;
 }
 
@@ -1900,6 +2034,9 @@ static struct parent *parent_create(struct net_device *ibd)
 	strncpy(parent->ipoib_main_interface, ibd->name, IFNAMSIZ);
 	parent_dev->dev_id = ibd->dev_id;
 
+#if (LINUX_VERSION_CODE <= KERNEL_VERSION(3,0,0))
+	parent->vlgrp = NULL;
+#endif
 	return parent;
 
 out_unreg:
@@ -1935,7 +2072,8 @@ static void parent_free_all(void)
 /* netdev events handlers */
 static inline int is_ipoib_pif_intf(struct net_device *dev)
 {
-	if (ARPHRD_INFINIBAND == dev->type && dev->priv_flags & IFF_EIPOIB_PIF)
+
+    if (ARPHRD_INFINIBAND == dev->type && dev->priv_flags & IFF_EIPOIB_PIF)
 		return 1;
 	return 0;
 }
